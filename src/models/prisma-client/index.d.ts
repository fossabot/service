// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from 'graphql';
import { makePrismaClientClass, BaseClientOptions, Model } from 'prisma-client-lib';
import { typeDefs } from './prisma-schema';

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  account: (where?: AccountWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  commentLike: (where?: CommentLikeWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  like: (where?: LikeWhereInput) => Promise<boolean>;
  pet: (where?: PetWhereInput) => Promise<boolean>;
  petImage: (where?: PetImageWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  postLike: (where?: PostLikeWhereInput) => Promise<boolean>;
  postTag: (where?: PostTagWhereInput) => Promise<boolean>;
  report: (where?: ReportWhereInput) => Promise<boolean>;
  review: (where?: ReviewWhereInput) => Promise<boolean>;
  reviewLike: (where?: ReviewLikeWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(query: string, variables?: { [key: string]: any }) => Promise<T>;

  /**
   * Queries
   */

  account: (where: AccountWhereUniqueInput) => AccountNullablePromise;
  accounts: (args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Account>;
  accountsConnection: (args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AccountConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  commentLike: (where: CommentLikeWhereUniqueInput) => CommentLikeNullablePromise;
  commentLikes: (args?: {
    where?: CommentLikeWhereInput;
    orderBy?: CommentLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CommentLike>;
  commentLikesConnection: (args?: {
    where?: CommentLikeWhereInput;
    orderBy?: CommentLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentLikeConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImageNullablePromise;
  images: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Image>;
  imagesConnection: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageConnectionPromise;
  like: (where: LikeWhereUniqueInput) => LikeNullablePromise;
  likes: (args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Like>;
  likesConnection: (args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LikeConnectionPromise;
  pet: (where: PetWhereUniqueInput) => PetNullablePromise;
  pets: (args?: {
    where?: PetWhereInput;
    orderBy?: PetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Pet>;
  petsConnection: (args?: {
    where?: PetWhereInput;
    orderBy?: PetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PetConnectionPromise;
  petImage: (where: PetImageWhereUniqueInput) => PetImageNullablePromise;
  petImages: (args?: {
    where?: PetImageWhereInput;
    orderBy?: PetImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PetImage>;
  petImagesConnection: (args?: {
    where?: PetImageWhereInput;
    orderBy?: PetImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PetImageConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostNullablePromise;
  posts: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Post>;
  postsConnection: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostConnectionPromise;
  postLike: (where: PostLikeWhereUniqueInput) => PostLikeNullablePromise;
  postLikes: (args?: {
    where?: PostLikeWhereInput;
    orderBy?: PostLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PostLike>;
  postLikesConnection: (args?: {
    where?: PostLikeWhereInput;
    orderBy?: PostLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostLikeConnectionPromise;
  postTag: (where: PostTagWhereUniqueInput) => PostTagNullablePromise;
  postTags: (args?: {
    where?: PostTagWhereInput;
    orderBy?: PostTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PostTag>;
  postTagsConnection: (args?: {
    where?: PostTagWhereInput;
    orderBy?: PostTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostTagConnectionPromise;
  report: (where: ReportWhereUniqueInput) => ReportNullablePromise;
  reports: (args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Report>;
  reportsConnection: (args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReportConnectionPromise;
  review: (where: ReviewWhereUniqueInput) => ReviewNullablePromise;
  reviews: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Review>;
  reviewsConnection: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReviewConnectionPromise;
  reviewLike: (where: ReviewLikeWhereUniqueInput) => ReviewLikeNullablePromise;
  reviewLikes: (args?: {
    where?: ReviewLikeWhereInput;
    orderBy?: ReviewLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ReviewLike>;
  reviewLikesConnection: (args?: {
    where?: ReviewLikeWhereInput;
    orderBy?: ReviewLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReviewLikeConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagNullablePromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccount: (data: AccountCreateInput) => AccountPromise;
  updateAccount: (args: {
    data: AccountUpdateInput;
    where: AccountWhereUniqueInput;
  }) => AccountPromise;
  updateManyAccounts: (args: {
    data: AccountUpdateManyMutationInput;
    where?: AccountWhereInput;
  }) => BatchPayloadPromise;
  upsertAccount: (args: {
    where: AccountWhereUniqueInput;
    create: AccountCreateInput;
    update: AccountUpdateInput;
  }) => AccountPromise;
  deleteAccount: (where: AccountWhereUniqueInput) => AccountPromise;
  deleteManyAccounts: (where?: AccountWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createCommentLike: (data: CommentLikeCreateInput) => CommentLikePromise;
  updateCommentLike: (args: {
    data: CommentLikeUpdateInput;
    where: CommentLikeWhereUniqueInput;
  }) => CommentLikePromise;
  upsertCommentLike: (args: {
    where: CommentLikeWhereUniqueInput;
    create: CommentLikeCreateInput;
    update: CommentLikeUpdateInput;
  }) => CommentLikePromise;
  deleteCommentLike: (where: CommentLikeWhereUniqueInput) => CommentLikePromise;
  deleteManyCommentLikes: (where?: CommentLikeWhereInput) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (args: { data: ImageUpdateInput; where: ImageWhereUniqueInput }) => ImagePromise;
  updateManyImages: (args: {
    data: ImageUpdateManyMutationInput;
    where?: ImageWhereInput;
  }) => BatchPayloadPromise;
  upsertImage: (args: {
    where: ImageWhereUniqueInput;
    create: ImageCreateInput;
    update: ImageUpdateInput;
  }) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createLike: (data: LikeCreateInput) => LikePromise;
  updateLike: (args: { data: LikeUpdateInput; where: LikeWhereUniqueInput }) => LikePromise;
  updateManyLikes: (args: {
    data: LikeUpdateManyMutationInput;
    where?: LikeWhereInput;
  }) => BatchPayloadPromise;
  upsertLike: (args: {
    where: LikeWhereUniqueInput;
    create: LikeCreateInput;
    update: LikeUpdateInput;
  }) => LikePromise;
  deleteLike: (where: LikeWhereUniqueInput) => LikePromise;
  deleteManyLikes: (where?: LikeWhereInput) => BatchPayloadPromise;
  createPet: (data: PetCreateInput) => PetPromise;
  updatePet: (args: { data: PetUpdateInput; where: PetWhereUniqueInput }) => PetPromise;
  updateManyPets: (args: {
    data: PetUpdateManyMutationInput;
    where?: PetWhereInput;
  }) => BatchPayloadPromise;
  upsertPet: (args: {
    where: PetWhereUniqueInput;
    create: PetCreateInput;
    update: PetUpdateInput;
  }) => PetPromise;
  deletePet: (where: PetWhereUniqueInput) => PetPromise;
  deleteManyPets: (where?: PetWhereInput) => BatchPayloadPromise;
  createPetImage: (data: PetImageCreateInput) => PetImagePromise;
  updatePetImage: (args: {
    data: PetImageUpdateInput;
    where: PetImageWhereUniqueInput;
  }) => PetImagePromise;
  upsertPetImage: (args: {
    where: PetImageWhereUniqueInput;
    create: PetImageCreateInput;
    update: PetImageUpdateInput;
  }) => PetImagePromise;
  deletePetImage: (where: PetImageWhereUniqueInput) => PetImagePromise;
  deleteManyPetImages: (where?: PetImageWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (args: { data: PostUpdateInput; where: PostWhereUniqueInput }) => PostPromise;
  updateManyPosts: (args: {
    data: PostUpdateManyMutationInput;
    where?: PostWhereInput;
  }) => BatchPayloadPromise;
  upsertPost: (args: {
    where: PostWhereUniqueInput;
    create: PostCreateInput;
    update: PostUpdateInput;
  }) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createPostLike: (data: PostLikeCreateInput) => PostLikePromise;
  updatePostLike: (args: {
    data: PostLikeUpdateInput;
    where: PostLikeWhereUniqueInput;
  }) => PostLikePromise;
  upsertPostLike: (args: {
    where: PostLikeWhereUniqueInput;
    create: PostLikeCreateInput;
    update: PostLikeUpdateInput;
  }) => PostLikePromise;
  deletePostLike: (where: PostLikeWhereUniqueInput) => PostLikePromise;
  deleteManyPostLikes: (where?: PostLikeWhereInput) => BatchPayloadPromise;
  createPostTag: (data: PostTagCreateInput) => PostTagPromise;
  updatePostTag: (args: {
    data: PostTagUpdateInput;
    where: PostTagWhereUniqueInput;
  }) => PostTagPromise;
  upsertPostTag: (args: {
    where: PostTagWhereUniqueInput;
    create: PostTagCreateInput;
    update: PostTagUpdateInput;
  }) => PostTagPromise;
  deletePostTag: (where: PostTagWhereUniqueInput) => PostTagPromise;
  deleteManyPostTags: (where?: PostTagWhereInput) => BatchPayloadPromise;
  createReport: (data: ReportCreateInput) => ReportPromise;
  updateReport: (args: { data: ReportUpdateInput; where: ReportWhereUniqueInput }) => ReportPromise;
  updateManyReports: (args: {
    data: ReportUpdateManyMutationInput;
    where?: ReportWhereInput;
  }) => BatchPayloadPromise;
  upsertReport: (args: {
    where: ReportWhereUniqueInput;
    create: ReportCreateInput;
    update: ReportUpdateInput;
  }) => ReportPromise;
  deleteReport: (where: ReportWhereUniqueInput) => ReportPromise;
  deleteManyReports: (where?: ReportWhereInput) => BatchPayloadPromise;
  createReview: (data: ReviewCreateInput) => ReviewPromise;
  updateReview: (args: { data: ReviewUpdateInput; where: ReviewWhereUniqueInput }) => ReviewPromise;
  updateManyReviews: (args: {
    data: ReviewUpdateManyMutationInput;
    where?: ReviewWhereInput;
  }) => BatchPayloadPromise;
  upsertReview: (args: {
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
  }) => ReviewPromise;
  deleteReview: (where: ReviewWhereUniqueInput) => ReviewPromise;
  deleteManyReviews: (where?: ReviewWhereInput) => BatchPayloadPromise;
  createReviewLike: (data: ReviewLikeCreateInput) => ReviewLikePromise;
  updateReviewLike: (args: {
    data: ReviewLikeUpdateInput;
    where: ReviewLikeWhereUniqueInput;
  }) => ReviewLikePromise;
  upsertReviewLike: (args: {
    where: ReviewLikeWhereUniqueInput;
    create: ReviewLikeCreateInput;
    update: ReviewLikeUpdateInput;
  }) => ReviewLikePromise;
  deleteReviewLike: (where: ReviewLikeWhereUniqueInput) => ReviewLikePromise;
  deleteManyReviewLikes: (where?: ReviewLikeWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: { data: TagUpdateInput; where: TagWhereUniqueInput }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: { data: UserUpdateInput; where: UserWhereUniqueInput }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  account: (where?: AccountSubscriptionWhereInput) => AccountSubscriptionPayloadSubscription;
  comment: (where?: CommentSubscriptionWhereInput) => CommentSubscriptionPayloadSubscription;
  commentLike: (
    where?: CommentLikeSubscriptionWhereInput,
  ) => CommentLikeSubscriptionPayloadSubscription;
  image: (where?: ImageSubscriptionWhereInput) => ImageSubscriptionPayloadSubscription;
  like: (where?: LikeSubscriptionWhereInput) => LikeSubscriptionPayloadSubscription;
  pet: (where?: PetSubscriptionWhereInput) => PetSubscriptionPayloadSubscription;
  petImage: (where?: PetImageSubscriptionWhereInput) => PetImageSubscriptionPayloadSubscription;
  post: (where?: PostSubscriptionWhereInput) => PostSubscriptionPayloadSubscription;
  postLike: (where?: PostLikeSubscriptionWhereInput) => PostLikeSubscriptionPayloadSubscription;
  postTag: (where?: PostTagSubscriptionWhereInput) => PostTagSubscriptionPayloadSubscription;
  report: (where?: ReportSubscriptionWhereInput) => ReportSubscriptionPayloadSubscription;
  review: (where?: ReviewSubscriptionWhereInput) => ReviewSubscriptionPayloadSubscription;
  reviewLike: (
    where?: ReviewLikeSubscriptionWhereInput,
  ) => ReviewLikeSubscriptionPayloadSubscription;
  tag: (where?: TagSubscriptionWhereInput) => TagSubscriptionPayloadSubscription;
  user: (where?: UserSubscriptionWhereInput) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PetImageOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type UserOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'phoneNumber_ASC'
  | 'phoneNumber_DESC'
  | 'address_ASC'
  | 'address_DESC'
  | 'bio_ASC'
  | 'bio_DESC'
  | 'dob_ASC'
  | 'dob_DESC'
  | 'settings_ASC'
  | 'settings_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type ImageOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'publicId_ASC'
  | 'publicId_DESC'
  | 'url_ASC'
  | 'url_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type TagOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'title_ASC'
  | 'title_DESC'
  | 'description_ASC'
  | 'description_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type PostStatus = 'Pending' | 'New' | 'Done' | 'Expired';

export type AccountStatus = 'Pending' | 'Active' | 'Deactive';

export type PetOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'type_ASC'
  | 'type_DESC'
  | 'info_ASC'
  | 'info_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type PostLikeOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type ReportOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'reason_ASC'
  | 'reason_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type AccountOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'username_ASC'
  | 'username_DESC'
  | 'password_ASC'
  | 'password_DESC'
  | 'email_ASC'
  | 'email_DESC'
  | 'role_ASC'
  | 'role_DESC'
  | 'status_ASC'
  | 'status_DESC'
  | 'settings_ASC'
  | 'settings_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type ReviewOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'message_ASC'
  | 'message_DESC'
  | 'stars_ASC'
  | 'stars_DESC'
  | 'likes_ASC'
  | 'likes_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED';

export type PetType = 'Dog' | 'Cat' | 'Bird' | 'Fish' | 'Snake' | 'Hare' | 'Hamster' | 'Other';

export type PostOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'title_ASC'
  | 'title_DESC'
  | 'description_ASC'
  | 'description_DESC'
  | 'location_ASC'
  | 'location_DESC'
  | 'price_ASC'
  | 'price_DESC'
  | 'dueDate_ASC'
  | 'dueDate_DESC'
  | 'settings_ASC'
  | 'settings_DESC'
  | 'status_ASC'
  | 'status_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type PostTagOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type CommentOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'message_ASC'
  | 'message_DESC'
  | 'likes_ASC'
  | 'likes_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type Role = 'Free' | 'Premium';

export type LikeOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'count_ASC'
  | 'count_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type CommentLikeOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export type ReviewLikeOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';

export interface ImageUpdateManyWithoutAccountInput {
  create?: Maybe<ImageCreateWithoutAccountInput[] | ImageCreateWithoutAccountInput>;
  delete?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  connect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  set?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  disconnect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  update?: Maybe<
    ImageUpdateWithWhereUniqueWithoutAccountInput[] | ImageUpdateWithWhereUniqueWithoutAccountInput
  >;
  upsert?: Maybe<
    ImageUpsertWithWhereUniqueWithoutAccountInput[] | ImageUpsertWithWhereUniqueWithoutAccountInput
  >;
  deleteMany?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  updateMany?: Maybe<ImageUpdateManyWithWhereNestedInput[] | ImageUpdateManyWithWhereNestedInput>;
}

export type AccountWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
  username?: Maybe<String>;
  email?: Maybe<String>;
}>;

export interface PostUpdateWithoutCommentsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  price?: Maybe<Int>;
  dueDate?: Maybe<DateTimeInput>;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  postTags?: Maybe<PostTagUpdateManyWithoutPostInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutPostInput>;
  reports?: Maybe<ReportUpdateManyWithoutPostInput>;
  account?: Maybe<AccountUpdateOneRequiredWithoutPostsInput>;
}

export interface LikeWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  count?: Maybe<Int>;
  count_not?: Maybe<Int>;
  count_in?: Maybe<Int[] | Int>;
  count_not_in?: Maybe<Int[] | Int>;
  count_lt?: Maybe<Int>;
  count_lte?: Maybe<Int>;
  count_gt?: Maybe<Int>;
  count_gte?: Maybe<Int>;
  account?: Maybe<AccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LikeWhereInput[] | LikeWhereInput>;
  OR?: Maybe<LikeWhereInput[] | LikeWhereInput>;
  NOT?: Maybe<LikeWhereInput[] | LikeWhereInput>;
}

export interface ReportCreateWithoutCreatedByInput {
  id?: Maybe<UUID>;
  reason: String;
  post: PostCreateOneWithoutReportsInput;
}

export interface LikeUpsertNestedInput {
  update: LikeUpdateDataInput;
  create: LikeCreateInput;
}

export interface PostCreateOneWithoutReportsInput {
  create?: Maybe<PostCreateWithoutReportsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface ReportUpdateManyWithoutPostInput {
  create?: Maybe<ReportCreateWithoutPostInput[] | ReportCreateWithoutPostInput>;
  delete?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  set?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  disconnect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  update?: Maybe<
    ReportUpdateWithWhereUniqueWithoutPostInput[] | ReportUpdateWithWhereUniqueWithoutPostInput
  >;
  upsert?: Maybe<
    ReportUpsertWithWhereUniqueWithoutPostInput[] | ReportUpsertWithWhereUniqueWithoutPostInput
  >;
  deleteMany?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  updateMany?: Maybe<ReportUpdateManyWithWhereNestedInput[] | ReportUpdateManyWithWhereNestedInput>;
}

export interface PostCreateWithoutReportsInput {
  id?: Maybe<UUID>;
  title: String;
  description?: Maybe<String>;
  location: String;
  price?: Maybe<Int>;
  dueDate: DateTimeInput;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  postTags?: Maybe<PostTagCreateManyWithoutPostInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  reviews?: Maybe<ReviewCreateManyWithoutPostInput>;
  account: AccountCreateOneWithoutPostsInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface AccountUpdateInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserUpdateManyWithoutAccountInput>;
  posts?: Maybe<PostUpdateManyWithoutAccountInput>;
  pets?: Maybe<PetUpdateManyWithoutAccountInput>;
  images?: Maybe<ImageUpdateManyWithoutAccountInput>;
  comments?: Maybe<CommentUpdateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageUpdateManyWithoutAccountInput>;
  like?: Maybe<LikeUpdateManyWithoutAccountInput>;
  reports?: Maybe<ReportUpdateManyWithoutCreatedByInput>;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagWhereInput>;
  AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  OR?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  NOT?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
}

export interface UserUpdateManyWithoutAccountInput {
  create?: Maybe<UserCreateWithoutAccountInput[] | UserCreateWithoutAccountInput>;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    UserUpdateWithWhereUniqueWithoutAccountInput[] | UserUpdateWithWhereUniqueWithoutAccountInput
  >;
  upsert?: Maybe<
    UserUpsertWithWhereUniqueWithoutAccountInput[] | UserUpsertWithWhereUniqueWithoutAccountInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput>;
}

export interface ReviewWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  stars?: Maybe<Int>;
  stars_not?: Maybe<Int>;
  stars_in?: Maybe<Int[] | Int>;
  stars_not_in?: Maybe<Int[] | Int>;
  stars_lt?: Maybe<Int>;
  stars_lte?: Maybe<Int>;
  stars_gt?: Maybe<Int>;
  stars_gte?: Maybe<Int>;
  image?: Maybe<ImageWhereInput>;
  likes?: Maybe<Int>;
  likes_not?: Maybe<Int>;
  likes_in?: Maybe<Int[] | Int>;
  likes_not_in?: Maybe<Int[] | Int>;
  likes_lt?: Maybe<Int>;
  likes_lte?: Maybe<Int>;
  likes_gt?: Maybe<Int>;
  likes_gte?: Maybe<Int>;
  post?: Maybe<PostWhereInput>;
  createdBy?: Maybe<AccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
  OR?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
  NOT?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
}

export interface UserUpdateWithWhereUniqueWithoutAccountInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutAccountDataInput;
}

export interface CommentWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  image?: Maybe<ImageWhereInput>;
  likes?: Maybe<Int>;
  likes_not?: Maybe<Int>;
  likes_in?: Maybe<Int[] | Int>;
  likes_not_in?: Maybe<Int[] | Int>;
  likes_lt?: Maybe<Int>;
  likes_lte?: Maybe<Int>;
  likes_gt?: Maybe<Int>;
  likes_gte?: Maybe<Int>;
  post?: Maybe<PostWhereInput>;
  createdBy?: Maybe<AccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export interface UserUpdateWithoutAccountDataInput {
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  address?: Maybe<Json>;
  bio?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  avatar?: Maybe<ImageUpdateOneInput>;
  settings?: Maybe<Json>;
}

export interface TagWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  postTags_every?: Maybe<PostTagWhereInput>;
  postTags_some?: Maybe<PostTagWhereInput>;
  postTags_none?: Maybe<PostTagWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TagWhereInput[] | TagWhereInput>;
  OR?: Maybe<TagWhereInput[] | TagWhereInput>;
  NOT?: Maybe<TagWhereInput[] | TagWhereInput>;
}

export interface ImageUpdateOneInput {
  create?: Maybe<ImageCreateInput>;
  update?: Maybe<ImageUpdateDataInput>;
  upsert?: Maybe<ImageUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface PostTagWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  post?: Maybe<PostWhereInput>;
  tag?: Maybe<TagWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostTagWhereInput[] | PostTagWhereInput>;
  OR?: Maybe<PostTagWhereInput[] | PostTagWhereInput>;
  NOT?: Maybe<PostTagWhereInput[] | PostTagWhereInput>;
}

export interface ImageUpdateDataInput {
  publicId?: Maybe<String>;
  url?: Maybe<String>;
  account?: Maybe<AccountUpdateOneRequiredWithoutImagesInput>;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostWhereInput>;
  AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  OR?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  NOT?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
}

export interface AccountUpdateOneRequiredWithoutImagesInput {
  create?: Maybe<AccountCreateWithoutImagesInput>;
  update?: Maybe<AccountUpdateWithoutImagesDataInput>;
  upsert?: Maybe<AccountUpsertWithoutImagesInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface PetImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PetImageWhereInput>;
  AND?: Maybe<PetImageSubscriptionWhereInput[] | PetImageSubscriptionWhereInput>;
  OR?: Maybe<PetImageSubscriptionWhereInput[] | PetImageSubscriptionWhereInput>;
  NOT?: Maybe<PetImageSubscriptionWhereInput[] | PetImageSubscriptionWhereInput>;
}

export interface AccountUpdateWithoutImagesDataInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserUpdateManyWithoutAccountInput>;
  posts?: Maybe<PostUpdateManyWithoutAccountInput>;
  pets?: Maybe<PetUpdateManyWithoutAccountInput>;
  comments?: Maybe<CommentUpdateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageUpdateManyWithoutAccountInput>;
  like?: Maybe<LikeUpdateManyWithoutAccountInput>;
  reports?: Maybe<ReportUpdateManyWithoutCreatedByInput>;
}

export interface PetSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PetWhereInput>;
  AND?: Maybe<PetSubscriptionWhereInput[] | PetSubscriptionWhereInput>;
  OR?: Maybe<PetSubscriptionWhereInput[] | PetSubscriptionWhereInput>;
  NOT?: Maybe<PetSubscriptionWhereInput[] | PetSubscriptionWhereInput>;
}

export interface PostUpdateManyWithoutAccountInput {
  create?: Maybe<PostCreateWithoutAccountInput[] | PostCreateWithoutAccountInput>;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    PostUpdateWithWhereUniqueWithoutAccountInput[] | PostUpdateWithWhereUniqueWithoutAccountInput
  >;
  upsert?: Maybe<
    PostUpsertWithWhereUniqueWithoutAccountInput[] | PostUpsertWithWhereUniqueWithoutAccountInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput>;
}

export interface LikeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LikeWhereInput>;
  AND?: Maybe<LikeSubscriptionWhereInput[] | LikeSubscriptionWhereInput>;
  OR?: Maybe<LikeSubscriptionWhereInput[] | LikeSubscriptionWhereInput>;
  NOT?: Maybe<LikeSubscriptionWhereInput[] | LikeSubscriptionWhereInput>;
}

export interface PostUpdateWithWhereUniqueWithoutAccountInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAccountDataInput;
}

export interface CommentLikeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentLikeWhereInput>;
  AND?: Maybe<CommentLikeSubscriptionWhereInput[] | CommentLikeSubscriptionWhereInput>;
  OR?: Maybe<CommentLikeSubscriptionWhereInput[] | CommentLikeSubscriptionWhereInput>;
  NOT?: Maybe<CommentLikeSubscriptionWhereInput[] | CommentLikeSubscriptionWhereInput>;
}

export interface PostUpdateWithoutAccountDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  price?: Maybe<Int>;
  dueDate?: Maybe<DateTimeInput>;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  postTags?: Maybe<PostTagUpdateManyWithoutPostInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutPostInput>;
  reports?: Maybe<ReportUpdateManyWithoutPostInput>;
}

export interface AccountSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AccountWhereInput>;
  AND?: Maybe<AccountSubscriptionWhereInput[] | AccountSubscriptionWhereInput>;
  OR?: Maybe<AccountSubscriptionWhereInput[] | AccountSubscriptionWhereInput>;
  NOT?: Maybe<AccountSubscriptionWhereInput[] | AccountSubscriptionWhereInput>;
}

export interface PostTagUpdateManyWithoutPostInput {
  create?: Maybe<PostTagCreateWithoutPostInput[] | PostTagCreateWithoutPostInput>;
  delete?: Maybe<PostTagWhereUniqueInput[] | PostTagWhereUniqueInput>;
  connect?: Maybe<PostTagWhereUniqueInput[] | PostTagWhereUniqueInput>;
  set?: Maybe<PostTagWhereUniqueInput[] | PostTagWhereUniqueInput>;
  disconnect?: Maybe<PostTagWhereUniqueInput[] | PostTagWhereUniqueInput>;
  update?: Maybe<
    PostTagUpdateWithWhereUniqueWithoutPostInput[] | PostTagUpdateWithWhereUniqueWithoutPostInput
  >;
  upsert?: Maybe<
    PostTagUpsertWithWhereUniqueWithoutPostInput[] | PostTagUpsertWithWhereUniqueWithoutPostInput
  >;
  deleteMany?: Maybe<PostTagScalarWhereInput[] | PostTagScalarWhereInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  address?: Maybe<Json>;
  bio?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  settings?: Maybe<Json>;
}

export interface PostTagUpdateWithWhereUniqueWithoutPostInput {
  where: PostTagWhereUniqueInput;
  data: PostTagUpdateWithoutPostDataInput;
}

export interface AccountUpdateWithoutUsersDataInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  posts?: Maybe<PostUpdateManyWithoutAccountInput>;
  pets?: Maybe<PetUpdateManyWithoutAccountInput>;
  images?: Maybe<ImageUpdateManyWithoutAccountInput>;
  comments?: Maybe<CommentUpdateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageUpdateManyWithoutAccountInput>;
  like?: Maybe<LikeUpdateManyWithoutAccountInput>;
  reports?: Maybe<ReportUpdateManyWithoutCreatedByInput>;
}

export interface PostTagUpdateWithoutPostDataInput {
  tag?: Maybe<TagUpdateOneRequiredWithoutPostTagsInput>;
}

export interface AccountUpdateOneRequiredWithoutUsersInput {
  create?: Maybe<AccountCreateWithoutUsersInput>;
  update?: Maybe<AccountUpdateWithoutUsersDataInput>;
  upsert?: Maybe<AccountUpsertWithoutUsersInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface TagUpdateOneRequiredWithoutPostTagsInput {
  create?: Maybe<TagCreateWithoutPostTagsInput>;
  update?: Maybe<TagUpdateWithoutPostTagsDataInput>;
  upsert?: Maybe<TagUpsertWithoutPostTagsInput>;
  connect?: Maybe<TagWhereUniqueInput>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  address?: Maybe<Json>;
  bio?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  avatar?: Maybe<ImageUpdateOneInput>;
  settings?: Maybe<Json>;
  account?: Maybe<AccountUpdateOneRequiredWithoutUsersInput>;
}

export interface TagUpdateWithoutPostTagsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface AccountCreateOneWithoutUsersInput {
  create?: Maybe<AccountCreateWithoutUsersInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface TagUpsertWithoutPostTagsInput {
  update: TagUpdateWithoutPostTagsDataInput;
  create: TagCreateWithoutPostTagsInput;
}

export type ImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
  publicId?: Maybe<String>;
}>;

export interface PostTagUpsertWithWhereUniqueWithoutPostInput {
  where: PostTagWhereUniqueInput;
  update: PostTagUpdateWithoutPostDataInput;
  create: PostTagCreateWithoutPostInput;
}

export interface PostTagUpsertWithWhereUniqueWithoutTagInput {
  where: PostTagWhereUniqueInput;
  update: PostTagUpdateWithoutTagDataInput;
  create: PostTagCreateWithoutTagInput;
}

export interface PostTagScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostTagScalarWhereInput[] | PostTagScalarWhereInput>;
  OR?: Maybe<PostTagScalarWhereInput[] | PostTagScalarWhereInput>;
  NOT?: Maybe<PostTagScalarWhereInput[] | PostTagScalarWhereInput>;
}

export type LikeWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface CommentUpdateManyWithoutPostInput {
  create?: Maybe<CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput>;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    CommentUpdateWithWhereUniqueWithoutPostInput[] | CommentUpdateWithWhereUniqueWithoutPostInput
  >;
  upsert?: Maybe<
    CommentUpsertWithWhereUniqueWithoutPostInput[] | CommentUpsertWithWhereUniqueWithoutPostInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    CommentUpdateManyWithWhereNestedInput[] | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface PostTagUpdateManyWithoutTagInput {
  create?: Maybe<PostTagCreateWithoutTagInput[] | PostTagCreateWithoutTagInput>;
  delete?: Maybe<PostTagWhereUniqueInput[] | PostTagWhereUniqueInput>;
  connect?: Maybe<PostTagWhereUniqueInput[] | PostTagWhereUniqueInput>;
  set?: Maybe<PostTagWhereUniqueInput[] | PostTagWhereUniqueInput>;
  disconnect?: Maybe<PostTagWhereUniqueInput[] | PostTagWhereUniqueInput>;
  update?: Maybe<
    PostTagUpdateWithWhereUniqueWithoutTagInput[] | PostTagUpdateWithWhereUniqueWithoutTagInput
  >;
  upsert?: Maybe<
    PostTagUpsertWithWhereUniqueWithoutTagInput[] | PostTagUpsertWithWhereUniqueWithoutTagInput
  >;
  deleteMany?: Maybe<PostTagScalarWhereInput[] | PostTagScalarWhereInput>;
}

export interface CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutPostDataInput;
}

export type PetWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface CommentUpdateWithoutPostDataInput {
  message?: Maybe<String>;
  image?: Maybe<ImageUpdateOneInput>;
  likes?: Maybe<Int>;
  createdBy?: Maybe<AccountUpdateOneRequiredWithoutCommentsInput>;
}

export interface PostTagCreateManyWithoutTagInput {
  create?: Maybe<PostTagCreateWithoutTagInput[] | PostTagCreateWithoutTagInput>;
  connect?: Maybe<PostTagWhereUniqueInput[] | PostTagWhereUniqueInput>;
}

export interface AccountUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<AccountCreateWithoutCommentsInput>;
  update?: Maybe<AccountUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<AccountUpsertWithoutCommentsInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export type PetImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface AccountUpdateWithoutCommentsDataInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserUpdateManyWithoutAccountInput>;
  posts?: Maybe<PostUpdateManyWithoutAccountInput>;
  pets?: Maybe<PetUpdateManyWithoutAccountInput>;
  images?: Maybe<ImageUpdateManyWithoutAccountInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageUpdateManyWithoutAccountInput>;
  like?: Maybe<LikeUpdateManyWithoutAccountInput>;
  reports?: Maybe<ReportUpdateManyWithoutCreatedByInput>;
}

export interface ReviewUpdateDataInput {
  message?: Maybe<String>;
  stars?: Maybe<Int>;
  image?: Maybe<ImageUpdateOneInput>;
  likes?: Maybe<Int>;
  post?: Maybe<PostUpdateOneRequiredWithoutReviewsInput>;
  createdBy?: Maybe<AccountUpdateOneRequiredWithoutReviewsInput>;
}

export interface PetUpdateManyWithoutAccountInput {
  create?: Maybe<PetCreateWithoutAccountInput[] | PetCreateWithoutAccountInput>;
  delete?: Maybe<PetWhereUniqueInput[] | PetWhereUniqueInput>;
  connect?: Maybe<PetWhereUniqueInput[] | PetWhereUniqueInput>;
  set?: Maybe<PetWhereUniqueInput[] | PetWhereUniqueInput>;
  disconnect?: Maybe<PetWhereUniqueInput[] | PetWhereUniqueInput>;
  update?: Maybe<
    PetUpdateWithWhereUniqueWithoutAccountInput[] | PetUpdateWithWhereUniqueWithoutAccountInput
  >;
  upsert?: Maybe<
    PetUpsertWithWhereUniqueWithoutAccountInput[] | PetUpsertWithWhereUniqueWithoutAccountInput
  >;
  deleteMany?: Maybe<PetScalarWhereInput[] | PetScalarWhereInput>;
  updateMany?: Maybe<PetUpdateManyWithWhereNestedInput[] | PetUpdateManyWithWhereNestedInput>;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface PetUpdateWithWhereUniqueWithoutAccountInput {
  where: PetWhereUniqueInput;
  data: PetUpdateWithoutAccountDataInput;
}

export interface ReviewCreateOneInput {
  create?: Maybe<ReviewCreateInput>;
  connect?: Maybe<ReviewWhereUniqueInput>;
}

export interface PetUpdateWithoutAccountDataInput {
  type?: Maybe<PetType>;
  info?: Maybe<Json>;
  post?: Maybe<PostUpdateOneRequiredInput>;
}

export type PostLikeWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface PostUpdateOneRequiredInput {
  create?: Maybe<PostCreateInput>;
  update?: Maybe<PostUpdateDataInput>;
  upsert?: Maybe<PostUpsertNestedInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PostLikeWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  post?: Maybe<PostWhereInput>;
  like?: Maybe<LikeWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostLikeWhereInput[] | PostLikeWhereInput>;
  OR?: Maybe<PostLikeWhereInput[] | PostLikeWhereInput>;
  NOT?: Maybe<PostLikeWhereInput[] | PostLikeWhereInput>;
}

export interface PostUpdateDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  price?: Maybe<Int>;
  dueDate?: Maybe<DateTimeInput>;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  postTags?: Maybe<PostTagUpdateManyWithoutPostInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutPostInput>;
  reports?: Maybe<ReportUpdateManyWithoutPostInput>;
  account?: Maybe<AccountUpdateOneRequiredWithoutPostsInput>;
}

export interface ReviewUpdateInput {
  message?: Maybe<String>;
  stars?: Maybe<Int>;
  image?: Maybe<ImageUpdateOneInput>;
  likes?: Maybe<Int>;
  post?: Maybe<PostUpdateOneRequiredWithoutReviewsInput>;
  createdBy?: Maybe<AccountUpdateOneRequiredWithoutReviewsInput>;
}

export interface ReviewUpdateManyWithoutPostInput {
  create?: Maybe<ReviewCreateWithoutPostInput[] | ReviewCreateWithoutPostInput>;
  delete?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  set?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  disconnect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  update?: Maybe<
    ReviewUpdateWithWhereUniqueWithoutPostInput[] | ReviewUpdateWithWhereUniqueWithoutPostInput
  >;
  upsert?: Maybe<
    ReviewUpsertWithWhereUniqueWithoutPostInput[] | ReviewUpsertWithWhereUniqueWithoutPostInput
  >;
  deleteMany?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  updateMany?: Maybe<ReviewUpdateManyWithWhereNestedInput[] | ReviewUpdateManyWithWhereNestedInput>;
}

export interface ReportUpdateManyMutationInput {
  reason?: Maybe<String>;
}

export interface ReviewUpdateWithWhereUniqueWithoutPostInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutPostDataInput;
}

export interface ReportUpdateInput {
  reason?: Maybe<String>;
  post?: Maybe<PostUpdateOneRequiredWithoutReportsInput>;
  createdBy?: Maybe<AccountUpdateOneRequiredWithoutReportsInput>;
}

export interface ReviewUpdateWithoutPostDataInput {
  message?: Maybe<String>;
  stars?: Maybe<Int>;
  image?: Maybe<ImageUpdateOneInput>;
  likes?: Maybe<Int>;
  createdBy?: Maybe<AccountUpdateOneRequiredWithoutReviewsInput>;
}

export interface PostUpsertWithoutPostTagsInput {
  update: PostUpdateWithoutPostTagsDataInput;
  create: PostCreateWithoutPostTagsInput;
}

export interface AccountUpdateOneRequiredWithoutReviewsInput {
  create?: Maybe<AccountCreateWithoutReviewsInput>;
  update?: Maybe<AccountUpdateWithoutReviewsDataInput>;
  upsert?: Maybe<AccountUpsertWithoutReviewsInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface PostUpdateWithoutPostTagsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  price?: Maybe<Int>;
  dueDate?: Maybe<DateTimeInput>;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutPostInput>;
  reports?: Maybe<ReportUpdateManyWithoutPostInput>;
  account?: Maybe<AccountUpdateOneRequiredWithoutPostsInput>;
}

export interface AccountUpdateWithoutReviewsDataInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserUpdateManyWithoutAccountInput>;
  posts?: Maybe<PostUpdateManyWithoutAccountInput>;
  pets?: Maybe<PetUpdateManyWithoutAccountInput>;
  images?: Maybe<ImageUpdateManyWithoutAccountInput>;
  comments?: Maybe<CommentUpdateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageUpdateManyWithoutAccountInput>;
  like?: Maybe<LikeUpdateManyWithoutAccountInput>;
  reports?: Maybe<ReportUpdateManyWithoutCreatedByInput>;
}

export interface PostTagUpdateInput {
  post?: Maybe<PostUpdateOneRequiredWithoutPostTagsInput>;
  tag?: Maybe<TagUpdateOneRequiredWithoutPostTagsInput>;
}

export interface LikeUpdateManyMutationInput {
  count?: Maybe<Int>;
}

export interface PostCreateWithoutPostTagsInput {
  id?: Maybe<UUID>;
  title: String;
  description?: Maybe<String>;
  location: String;
  price?: Maybe<Int>;
  dueDate: DateTimeInput;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  reviews?: Maybe<ReviewCreateManyWithoutPostInput>;
  reports?: Maybe<ReportCreateManyWithoutPostInput>;
  account: AccountCreateOneWithoutPostsInput;
}

export interface ImageUpdateWithWhereUniqueWithoutAccountInput {
  where: ImageWhereUniqueInput;
  data: ImageUpdateWithoutAccountDataInput;
}

export interface PostTagCreateInput {
  id?: Maybe<UUID>;
  post: PostCreateOneWithoutPostTagsInput;
  tag: TagCreateOneWithoutPostTagsInput;
}

export interface ImageUpdateWithoutAccountDataInput {
  publicId?: Maybe<String>;
  url?: Maybe<String>;
}

export interface PostLikeUpdateInput {
  post?: Maybe<PostUpdateOneRequiredInput>;
  like?: Maybe<LikeUpdateOneRequiredInput>;
}

export interface ImageUpsertWithWhereUniqueWithoutAccountInput {
  where: ImageWhereUniqueInput;
  update: ImageUpdateWithoutAccountDataInput;
  create: ImageCreateWithoutAccountInput;
}

export interface PostLikeCreateInput {
  id?: Maybe<UUID>;
  post: PostCreateOneInput;
  like: LikeCreateOneInput;
}

export interface ImageScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  publicId?: Maybe<String>;
  publicId_not?: Maybe<String>;
  publicId_in?: Maybe<String[] | String>;
  publicId_not_in?: Maybe<String[] | String>;
  publicId_lt?: Maybe<String>;
  publicId_lte?: Maybe<String>;
  publicId_gt?: Maybe<String>;
  publicId_gte?: Maybe<String>;
  publicId_contains?: Maybe<String>;
  publicId_not_contains?: Maybe<String>;
  publicId_starts_with?: Maybe<String>;
  publicId_not_starts_with?: Maybe<String>;
  publicId_ends_with?: Maybe<String>;
  publicId_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  OR?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  NOT?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
}

export interface PostUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  price?: Maybe<Int>;
  dueDate?: Maybe<DateTimeInput>;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  postTags?: Maybe<PostTagUpdateManyWithoutPostInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutPostInput>;
  reports?: Maybe<ReportUpdateManyWithoutPostInput>;
  account?: Maybe<AccountUpdateOneRequiredWithoutPostsInput>;
}

export interface ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput;
  data: ImageUpdateManyDataInput;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface ImageUpdateManyDataInput {
  publicId?: Maybe<String>;
  url?: Maybe<String>;
}

export interface AccountUpdateOneRequiredWithoutPetImagesInput {
  create?: Maybe<AccountCreateWithoutPetImagesInput>;
  update?: Maybe<AccountUpdateWithoutPetImagesDataInput>;
  upsert?: Maybe<AccountUpsertWithoutPetImagesInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface CommentUpdateManyWithoutCreatedByInput {
  create?: Maybe<CommentCreateWithoutCreatedByInput[] | CommentCreateWithoutCreatedByInput>;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutCreatedByInput[]
    | CommentUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutCreatedByInput[]
    | CommentUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    CommentUpdateManyWithWhereNestedInput[] | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface AccountCreateWithoutPetImagesInput {
  id?: Maybe<UUID>;
  username: String;
  password: String;
  email: String;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserCreateManyWithoutAccountInput>;
  posts?: Maybe<PostCreateManyWithoutAccountInput>;
  pets?: Maybe<PetCreateManyWithoutAccountInput>;
  images?: Maybe<ImageCreateManyWithoutAccountInput>;
  comments?: Maybe<CommentCreateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewCreateManyWithoutCreatedByInput>;
  like?: Maybe<LikeCreateManyWithoutAccountInput>;
  reports?: Maybe<ReportCreateManyWithoutCreatedByInput>;
}

export interface CommentUpdateWithWhereUniqueWithoutCreatedByInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutCreatedByDataInput;
}

export interface AccountCreateOneWithoutPetImagesInput {
  create?: Maybe<AccountCreateWithoutPetImagesInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface CommentUpdateWithoutCreatedByDataInput {
  message?: Maybe<String>;
  image?: Maybe<ImageUpdateOneInput>;
  likes?: Maybe<Int>;
  post?: Maybe<PostUpdateOneRequiredWithoutCommentsInput>;
}

export interface PetUpdateManyMutationInput {
  type?: Maybe<PetType>;
  info?: Maybe<Json>;
}

export interface PostUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<PostCreateWithoutCommentsInput>;
  update?: Maybe<PostUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<PostUpsertWithoutCommentsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface UserCreateManyWithoutAccountInput {
  create?: Maybe<UserCreateWithoutAccountInput[] | UserCreateWithoutAccountInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface PetImageWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  image?: Maybe<ImageWhereInput>;
  pet?: Maybe<PetWhereInput>;
  account?: Maybe<AccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PetImageWhereInput[] | PetImageWhereInput>;
  OR?: Maybe<PetImageWhereInput[] | PetImageWhereInput>;
  NOT?: Maybe<PetImageWhereInput[] | PetImageWhereInput>;
}

export interface ImageCreateOneInput {
  create?: Maybe<ImageCreateInput>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface LikeUpdateInput {
  count?: Maybe<Int>;
  account?: Maybe<AccountUpdateOneRequiredWithoutLikeInput>;
}

export interface AccountCreateOneWithoutImagesInput {
  create?: Maybe<AccountCreateWithoutImagesInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface ReportUpdateWithWhereUniqueWithoutPostInput {
  where: ReportWhereUniqueInput;
  data: ReportUpdateWithoutPostDataInput;
}

export interface PostCreateManyWithoutAccountInput {
  create?: Maybe<PostCreateWithoutAccountInput[] | PostCreateWithoutAccountInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface ReportUpdateWithoutPostDataInput {
  reason?: Maybe<String>;
  createdBy?: Maybe<AccountUpdateOneRequiredWithoutReportsInput>;
}

export interface PostTagCreateManyWithoutPostInput {
  create?: Maybe<PostTagCreateWithoutPostInput[] | PostTagCreateWithoutPostInput>;
  connect?: Maybe<PostTagWhereUniqueInput[] | PostTagWhereUniqueInput>;
}

export interface AccountUpdateOneRequiredWithoutReportsInput {
  create?: Maybe<AccountCreateWithoutReportsInput>;
  update?: Maybe<AccountUpdateWithoutReportsDataInput>;
  upsert?: Maybe<AccountUpsertWithoutReportsInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface TagCreateOneWithoutPostTagsInput {
  create?: Maybe<TagCreateWithoutPostTagsInput>;
  connect?: Maybe<TagWhereUniqueInput>;
}

export interface AccountUpdateWithoutReportsDataInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserUpdateManyWithoutAccountInput>;
  posts?: Maybe<PostUpdateManyWithoutAccountInput>;
  pets?: Maybe<PetUpdateManyWithoutAccountInput>;
  images?: Maybe<ImageUpdateManyWithoutAccountInput>;
  comments?: Maybe<CommentUpdateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageUpdateManyWithoutAccountInput>;
  like?: Maybe<LikeUpdateManyWithoutAccountInput>;
}

export interface CommentCreateManyWithoutPostInput {
  create?: Maybe<CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface ReviewUpdateManyWithoutCreatedByInput {
  create?: Maybe<ReviewCreateWithoutCreatedByInput[] | ReviewCreateWithoutCreatedByInput>;
  delete?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  set?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  disconnect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  update?: Maybe<
    | ReviewUpdateWithWhereUniqueWithoutCreatedByInput[]
    | ReviewUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | ReviewUpsertWithWhereUniqueWithoutCreatedByInput[]
    | ReviewUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  updateMany?: Maybe<ReviewUpdateManyWithWhereNestedInput[] | ReviewUpdateManyWithWhereNestedInput>;
}

export interface AccountCreateOneWithoutCommentsInput {
  create?: Maybe<AccountCreateWithoutCommentsInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface ReviewUpdateWithWhereUniqueWithoutCreatedByInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutCreatedByDataInput;
}

export interface PetCreateManyWithoutAccountInput {
  create?: Maybe<PetCreateWithoutAccountInput[] | PetCreateWithoutAccountInput>;
  connect?: Maybe<PetWhereUniqueInput[] | PetWhereUniqueInput>;
}

export interface ReviewUpdateWithoutCreatedByDataInput {
  message?: Maybe<String>;
  stars?: Maybe<Int>;
  image?: Maybe<ImageUpdateOneInput>;
  likes?: Maybe<Int>;
  post?: Maybe<PostUpdateOneRequiredWithoutReviewsInput>;
}

export interface PostCreateOneInput {
  create?: Maybe<PostCreateInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PostUpdateOneRequiredWithoutReviewsInput {
  create?: Maybe<PostCreateWithoutReviewsInput>;
  update?: Maybe<PostUpdateWithoutReviewsDataInput>;
  upsert?: Maybe<PostUpsertWithoutReviewsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface ReviewCreateManyWithoutPostInput {
  create?: Maybe<ReviewCreateWithoutPostInput[] | ReviewCreateWithoutPostInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
}

export interface PostUpdateWithoutReviewsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  price?: Maybe<Int>;
  dueDate?: Maybe<DateTimeInput>;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  postTags?: Maybe<PostTagUpdateManyWithoutPostInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  reports?: Maybe<ReportUpdateManyWithoutPostInput>;
  account?: Maybe<AccountUpdateOneRequiredWithoutPostsInput>;
}

export interface AccountCreateOneWithoutReviewsInput {
  create?: Maybe<AccountCreateWithoutReviewsInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface AccountUpdateOneRequiredWithoutPostsInput {
  create?: Maybe<AccountCreateWithoutPostsInput>;
  update?: Maybe<AccountUpdateWithoutPostsDataInput>;
  upsert?: Maybe<AccountUpsertWithoutPostsInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface ImageCreateManyWithoutAccountInput {
  create?: Maybe<ImageCreateWithoutAccountInput[] | ImageCreateWithoutAccountInput>;
  connect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
}

export interface AccountUpdateWithoutPostsDataInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserUpdateManyWithoutAccountInput>;
  pets?: Maybe<PetUpdateManyWithoutAccountInput>;
  images?: Maybe<ImageUpdateManyWithoutAccountInput>;
  comments?: Maybe<CommentUpdateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageUpdateManyWithoutAccountInput>;
  like?: Maybe<LikeUpdateManyWithoutAccountInput>;
  reports?: Maybe<ReportUpdateManyWithoutCreatedByInput>;
}

export interface CommentCreateManyWithoutCreatedByInput {
  create?: Maybe<CommentCreateWithoutCreatedByInput[] | CommentCreateWithoutCreatedByInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface PetImageUpdateManyWithoutAccountInput {
  create?: Maybe<PetImageCreateWithoutAccountInput[] | PetImageCreateWithoutAccountInput>;
  delete?: Maybe<PetImageWhereUniqueInput[] | PetImageWhereUniqueInput>;
  connect?: Maybe<PetImageWhereUniqueInput[] | PetImageWhereUniqueInput>;
  set?: Maybe<PetImageWhereUniqueInput[] | PetImageWhereUniqueInput>;
  disconnect?: Maybe<PetImageWhereUniqueInput[] | PetImageWhereUniqueInput>;
  update?: Maybe<
    | PetImageUpdateWithWhereUniqueWithoutAccountInput[]
    | PetImageUpdateWithWhereUniqueWithoutAccountInput
  >;
  upsert?: Maybe<
    | PetImageUpsertWithWhereUniqueWithoutAccountInput[]
    | PetImageUpsertWithWhereUniqueWithoutAccountInput
  >;
  deleteMany?: Maybe<PetImageScalarWhereInput[] | PetImageScalarWhereInput>;
}

export interface PostCreateOneWithoutCommentsInput {
  create?: Maybe<PostCreateWithoutCommentsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PetImageUpdateWithWhereUniqueWithoutAccountInput {
  where: PetImageWhereUniqueInput;
  data: PetImageUpdateWithoutAccountDataInput;
}

export interface ReportCreateManyWithoutPostInput {
  create?: Maybe<ReportCreateWithoutPostInput[] | ReportCreateWithoutPostInput>;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
}

export interface PetImageUpdateWithoutAccountDataInput {
  image?: Maybe<ImageUpdateOneRequiredInput>;
  pet?: Maybe<PetUpdateOneRequiredInput>;
}

export interface AccountCreateOneWithoutReportsInput {
  create?: Maybe<AccountCreateWithoutReportsInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface ImageUpdateOneRequiredInput {
  create?: Maybe<ImageCreateInput>;
  update?: Maybe<ImageUpdateDataInput>;
  upsert?: Maybe<ImageUpsertNestedInput>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface ReviewCreateManyWithoutCreatedByInput {
  create?: Maybe<ReviewCreateWithoutCreatedByInput[] | ReviewCreateWithoutCreatedByInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
}

export interface ImageUpsertNestedInput {
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface PostCreateOneWithoutReviewsInput {
  create?: Maybe<PostCreateWithoutReviewsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PetUpdateOneRequiredInput {
  create?: Maybe<PetCreateInput>;
  update?: Maybe<PetUpdateDataInput>;
  upsert?: Maybe<PetUpsertNestedInput>;
  connect?: Maybe<PetWhereUniqueInput>;
}

export interface AccountCreateOneWithoutPostsInput {
  create?: Maybe<AccountCreateWithoutPostsInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface PetUpdateDataInput {
  type?: Maybe<PetType>;
  info?: Maybe<Json>;
  post?: Maybe<PostUpdateOneRequiredInput>;
  account?: Maybe<AccountUpdateOneRequiredWithoutPetsInput>;
}

export interface PetImageCreateManyWithoutAccountInput {
  create?: Maybe<PetImageCreateWithoutAccountInput[] | PetImageCreateWithoutAccountInput>;
  connect?: Maybe<PetImageWhereUniqueInput[] | PetImageWhereUniqueInput>;
}

export interface AccountUpdateOneRequiredWithoutPetsInput {
  create?: Maybe<AccountCreateWithoutPetsInput>;
  update?: Maybe<AccountUpdateWithoutPetsDataInput>;
  upsert?: Maybe<AccountUpsertWithoutPetsInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface PetCreateOneInput {
  create?: Maybe<PetCreateInput>;
  connect?: Maybe<PetWhereUniqueInput>;
}

export interface AccountUpdateWithoutPetsDataInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserUpdateManyWithoutAccountInput>;
  posts?: Maybe<PostUpdateManyWithoutAccountInput>;
  images?: Maybe<ImageUpdateManyWithoutAccountInput>;
  comments?: Maybe<CommentUpdateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageUpdateManyWithoutAccountInput>;
  like?: Maybe<LikeUpdateManyWithoutAccountInput>;
  reports?: Maybe<ReportUpdateManyWithoutCreatedByInput>;
}

export interface AccountCreateOneWithoutPetsInput {
  create?: Maybe<AccountCreateWithoutPetsInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface LikeUpdateManyWithoutAccountInput {
  create?: Maybe<LikeCreateWithoutAccountInput[] | LikeCreateWithoutAccountInput>;
  delete?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  connect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  set?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  disconnect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
  update?: Maybe<
    LikeUpdateWithWhereUniqueWithoutAccountInput[] | LikeUpdateWithWhereUniqueWithoutAccountInput
  >;
  upsert?: Maybe<
    LikeUpsertWithWhereUniqueWithoutAccountInput[] | LikeUpsertWithWhereUniqueWithoutAccountInput
  >;
  deleteMany?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
  updateMany?: Maybe<LikeUpdateManyWithWhereNestedInput[] | LikeUpdateManyWithWhereNestedInput>;
}

export interface LikeCreateManyWithoutAccountInput {
  create?: Maybe<LikeCreateWithoutAccountInput[] | LikeCreateWithoutAccountInput>;
  connect?: Maybe<LikeWhereUniqueInput[] | LikeWhereUniqueInput>;
}

export interface LikeUpdateWithWhereUniqueWithoutAccountInput {
  where: LikeWhereUniqueInput;
  data: LikeUpdateWithoutAccountDataInput;
}

export interface ReportCreateManyWithoutCreatedByInput {
  create?: Maybe<ReportCreateWithoutCreatedByInput[] | ReportCreateWithoutCreatedByInput>;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
}

export interface LikeUpdateWithoutAccountDataInput {
  count?: Maybe<Int>;
}

export interface ReportWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  reason?: Maybe<String>;
  reason_not?: Maybe<String>;
  reason_in?: Maybe<String[] | String>;
  reason_not_in?: Maybe<String[] | String>;
  reason_lt?: Maybe<String>;
  reason_lte?: Maybe<String>;
  reason_gt?: Maybe<String>;
  reason_gte?: Maybe<String>;
  reason_contains?: Maybe<String>;
  reason_not_contains?: Maybe<String>;
  reason_starts_with?: Maybe<String>;
  reason_not_starts_with?: Maybe<String>;
  reason_ends_with?: Maybe<String>;
  reason_not_ends_with?: Maybe<String>;
  post?: Maybe<PostWhereInput>;
  createdBy?: Maybe<AccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReportWhereInput[] | ReportWhereInput>;
  OR?: Maybe<ReportWhereInput[] | ReportWhereInput>;
  NOT?: Maybe<ReportWhereInput[] | ReportWhereInput>;
}

export interface LikeUpsertWithWhereUniqueWithoutAccountInput {
  where: LikeWhereUniqueInput;
  update: LikeUpdateWithoutAccountDataInput;
  create: LikeCreateWithoutAccountInput;
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReviewWhereInput>;
  AND?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
  OR?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
  NOT?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
}

export interface LikeScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  count?: Maybe<Int>;
  count_not?: Maybe<Int>;
  count_in?: Maybe<Int[] | Int>;
  count_not_in?: Maybe<Int[] | Int>;
  count_lt?: Maybe<Int>;
  count_lte?: Maybe<Int>;
  count_gt?: Maybe<Int>;
  count_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
  OR?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
  NOT?: Maybe<LikeScalarWhereInput[] | LikeScalarWhereInput>;
}

export interface PostTagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostTagWhereInput>;
  AND?: Maybe<PostTagSubscriptionWhereInput[] | PostTagSubscriptionWhereInput>;
  OR?: Maybe<PostTagSubscriptionWhereInput[] | PostTagSubscriptionWhereInput>;
  NOT?: Maybe<PostTagSubscriptionWhereInput[] | PostTagSubscriptionWhereInput>;
}

export interface LikeUpdateManyWithWhereNestedInput {
  where: LikeScalarWhereInput;
  data: LikeUpdateManyDataInput;
}

export interface PostWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  dueDate?: Maybe<DateTimeInput>;
  dueDate_not?: Maybe<DateTimeInput>;
  dueDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dueDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dueDate_lt?: Maybe<DateTimeInput>;
  dueDate_lte?: Maybe<DateTimeInput>;
  dueDate_gt?: Maybe<DateTimeInput>;
  dueDate_gte?: Maybe<DateTimeInput>;
  status?: Maybe<PostStatus>;
  status_not?: Maybe<PostStatus>;
  status_in?: Maybe<PostStatus[] | PostStatus>;
  status_not_in?: Maybe<PostStatus[] | PostStatus>;
  postTags_every?: Maybe<PostTagWhereInput>;
  postTags_some?: Maybe<PostTagWhereInput>;
  postTags_none?: Maybe<PostTagWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  reviews_every?: Maybe<ReviewWhereInput>;
  reviews_some?: Maybe<ReviewWhereInput>;
  reviews_none?: Maybe<ReviewWhereInput>;
  reports_every?: Maybe<ReportWhereInput>;
  reports_some?: Maybe<ReportWhereInput>;
  reports_none?: Maybe<ReportWhereInput>;
  account?: Maybe<AccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostWhereInput[] | PostWhereInput>;
  OR?: Maybe<PostWhereInput[] | PostWhereInput>;
  NOT?: Maybe<PostWhereInput[] | PostWhereInput>;
}

export interface LikeUpdateManyDataInput {
  count?: Maybe<Int>;
}

export interface ImageWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  publicId?: Maybe<String>;
  publicId_not?: Maybe<String>;
  publicId_in?: Maybe<String[] | String>;
  publicId_not_in?: Maybe<String[] | String>;
  publicId_lt?: Maybe<String>;
  publicId_lte?: Maybe<String>;
  publicId_gt?: Maybe<String>;
  publicId_gte?: Maybe<String>;
  publicId_contains?: Maybe<String>;
  publicId_not_contains?: Maybe<String>;
  publicId_starts_with?: Maybe<String>;
  publicId_not_starts_with?: Maybe<String>;
  publicId_ends_with?: Maybe<String>;
  publicId_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  account?: Maybe<AccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  OR?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  NOT?: Maybe<ImageWhereInput[] | ImageWhereInput>;
}

export interface ReportUpdateManyWithoutCreatedByInput {
  create?: Maybe<ReportCreateWithoutCreatedByInput[] | ReportCreateWithoutCreatedByInput>;
  delete?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  set?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  disconnect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  update?: Maybe<
    | ReportUpdateWithWhereUniqueWithoutCreatedByInput[]
    | ReportUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | ReportUpsertWithWhereUniqueWithoutCreatedByInput[]
    | ReportUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  updateMany?: Maybe<ReportUpdateManyWithWhereNestedInput[] | ReportUpdateManyWithWhereNestedInput>;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface ReportUpdateWithWhereUniqueWithoutCreatedByInput {
  where: ReportWhereUniqueInput;
  data: ReportUpdateWithoutCreatedByDataInput;
}

export interface AccountUpsertWithoutUsersInput {
  update: AccountUpdateWithoutUsersDataInput;
  create: AccountCreateWithoutUsersInput;
}

export interface ReportUpdateWithoutCreatedByDataInput {
  reason?: Maybe<String>;
  post?: Maybe<PostUpdateOneRequiredWithoutReportsInput>;
}

export interface CommentLikeWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  comment?: Maybe<CommentWhereInput>;
  like?: Maybe<LikeWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentLikeWhereInput[] | CommentLikeWhereInput>;
  OR?: Maybe<CommentLikeWhereInput[] | CommentLikeWhereInput>;
  NOT?: Maybe<CommentLikeWhereInput[] | CommentLikeWhereInput>;
}

export interface PostUpdateOneRequiredWithoutReportsInput {
  create?: Maybe<PostCreateWithoutReportsInput>;
  update?: Maybe<PostUpdateWithoutReportsDataInput>;
  upsert?: Maybe<PostUpsertWithoutReportsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<UUID>;
  name: String;
  phoneNumber: String;
  address: Json;
  bio?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  avatar?: Maybe<ImageCreateOneInput>;
  settings?: Maybe<Json>;
  account: AccountCreateOneWithoutUsersInput;
}

export interface PostUpdateWithoutReportsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  price?: Maybe<Int>;
  dueDate?: Maybe<DateTimeInput>;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  postTags?: Maybe<PostTagUpdateManyWithoutPostInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutPostInput>;
  account?: Maybe<AccountUpdateOneRequiredWithoutPostsInput>;
}

export interface PostTagUpdateWithoutTagDataInput {
  post?: Maybe<PostUpdateOneRequiredWithoutPostTagsInput>;
}

export interface PostUpsertWithoutReportsInput {
  update: PostUpdateWithoutReportsDataInput;
  create: PostCreateWithoutReportsInput;
}

export interface TagUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  postTags?: Maybe<PostTagUpdateManyWithoutTagInput>;
}

export interface ReportUpsertWithWhereUniqueWithoutCreatedByInput {
  where: ReportWhereUniqueInput;
  update: ReportUpdateWithoutCreatedByDataInput;
  create: ReportCreateWithoutCreatedByInput;
}

export interface TagCreateInput {
  id?: Maybe<UUID>;
  title: String;
  description?: Maybe<String>;
  postTags?: Maybe<PostTagCreateManyWithoutTagInput>;
}

export interface ReportScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  reason?: Maybe<String>;
  reason_not?: Maybe<String>;
  reason_in?: Maybe<String[] | String>;
  reason_not_in?: Maybe<String[] | String>;
  reason_lt?: Maybe<String>;
  reason_lte?: Maybe<String>;
  reason_gt?: Maybe<String>;
  reason_gte?: Maybe<String>;
  reason_contains?: Maybe<String>;
  reason_not_contains?: Maybe<String>;
  reason_starts_with?: Maybe<String>;
  reason_not_starts_with?: Maybe<String>;
  reason_ends_with?: Maybe<String>;
  reason_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  OR?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  NOT?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
}

export interface ReviewUpdateOneRequiredInput {
  create?: Maybe<ReviewCreateInput>;
  update?: Maybe<ReviewUpdateDataInput>;
  upsert?: Maybe<ReviewUpsertNestedInput>;
  connect?: Maybe<ReviewWhereUniqueInput>;
}

export interface ReportUpdateManyWithWhereNestedInput {
  where: ReportScalarWhereInput;
  data: ReportUpdateManyDataInput;
}

export interface ReviewLikeCreateInput {
  id?: Maybe<UUID>;
  review: ReviewCreateOneInput;
  like: LikeCreateOneInput;
}

export interface ReportUpdateManyDataInput {
  reason?: Maybe<String>;
}

export interface UserWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  dob_not?: Maybe<DateTimeInput>;
  dob_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dob_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dob_lt?: Maybe<DateTimeInput>;
  dob_lte?: Maybe<DateTimeInput>;
  dob_gt?: Maybe<DateTimeInput>;
  dob_gte?: Maybe<DateTimeInput>;
  avatar?: Maybe<ImageWhereInput>;
  account?: Maybe<AccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface AccountUpsertWithoutPetsInput {
  update: AccountUpdateWithoutPetsDataInput;
  create: AccountCreateWithoutPetsInput;
}

export type PostTagWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface PetUpsertNestedInput {
  update: PetUpdateDataInput;
  create: PetCreateInput;
}

export type ReportWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface PetImageUpsertWithWhereUniqueWithoutAccountInput {
  where: PetImageWhereUniqueInput;
  update: PetImageUpdateWithoutAccountDataInput;
  create: PetImageCreateWithoutAccountInput;
}

export type ReviewWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface PetImageScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PetImageScalarWhereInput[] | PetImageScalarWhereInput>;
  OR?: Maybe<PetImageScalarWhereInput[] | PetImageScalarWhereInput>;
  NOT?: Maybe<PetImageScalarWhereInput[] | PetImageScalarWhereInput>;
}

export type ReviewLikeWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface AccountUpsertWithoutPostsInput {
  update: AccountUpdateWithoutPostsDataInput;
  create: AccountCreateWithoutPostsInput;
}

export interface PostUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  price?: Maybe<Int>;
  dueDate?: Maybe<DateTimeInput>;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
}

export interface PostUpsertWithoutReviewsInput {
  update: PostUpdateWithoutReviewsDataInput;
  create: PostCreateWithoutReviewsInput;
}

export interface AccountUpdateWithoutPetImagesDataInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserUpdateManyWithoutAccountInput>;
  posts?: Maybe<PostUpdateManyWithoutAccountInput>;
  pets?: Maybe<PetUpdateManyWithoutAccountInput>;
  images?: Maybe<ImageUpdateManyWithoutAccountInput>;
  comments?: Maybe<CommentUpdateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutCreatedByInput>;
  like?: Maybe<LikeUpdateManyWithoutAccountInput>;
  reports?: Maybe<ReportUpdateManyWithoutCreatedByInput>;
}

export interface ReviewUpsertWithWhereUniqueWithoutCreatedByInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutCreatedByDataInput;
  create: ReviewCreateWithoutCreatedByInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface ReviewScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  stars?: Maybe<Int>;
  stars_not?: Maybe<Int>;
  stars_in?: Maybe<Int[] | Int>;
  stars_not_in?: Maybe<Int[] | Int>;
  stars_lt?: Maybe<Int>;
  stars_lte?: Maybe<Int>;
  stars_gt?: Maybe<Int>;
  stars_gte?: Maybe<Int>;
  likes?: Maybe<Int>;
  likes_not?: Maybe<Int>;
  likes_in?: Maybe<Int[] | Int>;
  likes_not_in?: Maybe<Int[] | Int>;
  likes_lt?: Maybe<Int>;
  likes_lte?: Maybe<Int>;
  likes_gt?: Maybe<Int>;
  likes_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  OR?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  NOT?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
}

export interface PetUpdateInput {
  type?: Maybe<PetType>;
  info?: Maybe<Json>;
  post?: Maybe<PostUpdateOneRequiredInput>;
  account?: Maybe<AccountUpdateOneRequiredWithoutPetsInput>;
}

export interface ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput;
  data: ReviewUpdateManyDataInput;
}

export interface UserCreateWithoutAccountInput {
  id?: Maybe<UUID>;
  name: String;
  phoneNumber: String;
  address: Json;
  bio?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  avatar?: Maybe<ImageCreateOneInput>;
  settings?: Maybe<Json>;
}

export interface ReviewUpdateManyDataInput {
  message?: Maybe<String>;
  stars?: Maybe<Int>;
  likes?: Maybe<Int>;
}

export interface AccountCreateWithoutImagesInput {
  id?: Maybe<UUID>;
  username: String;
  password: String;
  email: String;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserCreateManyWithoutAccountInput>;
  posts?: Maybe<PostCreateManyWithoutAccountInput>;
  pets?: Maybe<PetCreateManyWithoutAccountInput>;
  comments?: Maybe<CommentCreateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewCreateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageCreateManyWithoutAccountInput>;
  like?: Maybe<LikeCreateManyWithoutAccountInput>;
  reports?: Maybe<ReportCreateManyWithoutCreatedByInput>;
}

export interface AccountUpsertWithoutReportsInput {
  update: AccountUpdateWithoutReportsDataInput;
  create: AccountCreateWithoutReportsInput;
}

export interface PostTagCreateWithoutPostInput {
  id?: Maybe<UUID>;
  tag: TagCreateOneWithoutPostTagsInput;
}

export interface ReportUpsertWithWhereUniqueWithoutPostInput {
  where: ReportWhereUniqueInput;
  update: ReportUpdateWithoutPostDataInput;
  create: ReportCreateWithoutPostInput;
}

export interface CommentCreateWithoutPostInput {
  id?: Maybe<UUID>;
  message: String;
  image?: Maybe<ImageCreateOneInput>;
  likes?: Maybe<Int>;
  createdBy: AccountCreateOneWithoutCommentsInput;
}

export interface PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput;
  create: PostCreateWithoutCommentsInput;
}

export interface PetCreateWithoutAccountInput {
  id?: Maybe<UUID>;
  type: PetType;
  info?: Maybe<Json>;
  post: PostCreateOneInput;
}

export interface CommentUpsertWithWhereUniqueWithoutCreatedByInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutCreatedByDataInput;
  create: CommentCreateWithoutCreatedByInput;
}

export interface ReviewCreateWithoutPostInput {
  id?: Maybe<UUID>;
  message: String;
  stars: Int;
  image?: Maybe<ImageCreateOneInput>;
  likes?: Maybe<Int>;
  createdBy: AccountCreateOneWithoutReviewsInput;
}

export interface CommentScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  likes?: Maybe<Int>;
  likes_not?: Maybe<Int>;
  likes_in?: Maybe<Int[] | Int>;
  likes_not_in?: Maybe<Int[] | Int>;
  likes_lt?: Maybe<Int>;
  likes_lte?: Maybe<Int>;
  likes_gt?: Maybe<Int>;
  likes_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface ImageCreateWithoutAccountInput {
  id?: Maybe<UUID>;
  publicId: String;
  url: String;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface PostCreateWithoutCommentsInput {
  id?: Maybe<UUID>;
  title: String;
  description?: Maybe<String>;
  location: String;
  price?: Maybe<Int>;
  dueDate: DateTimeInput;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  postTags?: Maybe<PostTagCreateManyWithoutPostInput>;
  reviews?: Maybe<ReviewCreateManyWithoutPostInput>;
  reports?: Maybe<ReportCreateManyWithoutPostInput>;
  account: AccountCreateOneWithoutPostsInput;
}

export interface CommentUpdateManyDataInput {
  message?: Maybe<String>;
  likes?: Maybe<Int>;
}

export interface AccountCreateWithoutReportsInput {
  id?: Maybe<UUID>;
  username: String;
  password: String;
  email: String;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserCreateManyWithoutAccountInput>;
  posts?: Maybe<PostCreateManyWithoutAccountInput>;
  pets?: Maybe<PetCreateManyWithoutAccountInput>;
  images?: Maybe<ImageCreateManyWithoutAccountInput>;
  comments?: Maybe<CommentCreateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewCreateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageCreateManyWithoutAccountInput>;
  like?: Maybe<LikeCreateManyWithoutAccountInput>;
}

export interface AccountUpsertWithoutReviewsInput {
  update: AccountUpdateWithoutReviewsDataInput;
  create: AccountCreateWithoutReviewsInput;
}

export interface PostCreateWithoutReviewsInput {
  id?: Maybe<UUID>;
  title: String;
  description?: Maybe<String>;
  location: String;
  price?: Maybe<Int>;
  dueDate: DateTimeInput;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  postTags?: Maybe<PostTagCreateManyWithoutPostInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  reports?: Maybe<ReportCreateManyWithoutPostInput>;
  account: AccountCreateOneWithoutPostsInput;
}

export interface ReviewUpsertWithWhereUniqueWithoutPostInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutPostDataInput;
  create: ReviewCreateWithoutPostInput;
}

export interface PetImageCreateWithoutAccountInput {
  id?: Maybe<UUID>;
  image: ImageCreateOneInput;
  pet: PetCreateOneInput;
}

export interface PostUpsertNestedInput {
  update: PostUpdateDataInput;
  create: PostCreateInput;
}

export interface AccountCreateWithoutPetsInput {
  id?: Maybe<UUID>;
  username: String;
  password: String;
  email: String;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserCreateManyWithoutAccountInput>;
  posts?: Maybe<PostCreateManyWithoutAccountInput>;
  images?: Maybe<ImageCreateManyWithoutAccountInput>;
  comments?: Maybe<CommentCreateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewCreateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageCreateManyWithoutAccountInput>;
  like?: Maybe<LikeCreateManyWithoutAccountInput>;
  reports?: Maybe<ReportCreateManyWithoutCreatedByInput>;
}

export interface PetUpsertWithWhereUniqueWithoutAccountInput {
  where: PetWhereUniqueInput;
  update: PetUpdateWithoutAccountDataInput;
  create: PetCreateWithoutAccountInput;
}

export interface PetWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  type?: Maybe<PetType>;
  type_not?: Maybe<PetType>;
  type_in?: Maybe<PetType[] | PetType>;
  type_not_in?: Maybe<PetType[] | PetType>;
  post?: Maybe<PostWhereInput>;
  account?: Maybe<AccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PetWhereInput[] | PetWhereInput>;
  OR?: Maybe<PetWhereInput[] | PetWhereInput>;
  NOT?: Maybe<PetWhereInput[] | PetWhereInput>;
}

export interface PetScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  type?: Maybe<PetType>;
  type_not?: Maybe<PetType>;
  type_in?: Maybe<PetType[] | PetType>;
  type_not_in?: Maybe<PetType[] | PetType>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PetScalarWhereInput[] | PetScalarWhereInput>;
  OR?: Maybe<PetScalarWhereInput[] | PetScalarWhereInput>;
  NOT?: Maybe<PetScalarWhereInput[] | PetScalarWhereInput>;
}

export interface ReportSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReportWhereInput>;
  AND?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
  OR?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
  NOT?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
}

export interface PetUpdateManyWithWhereNestedInput {
  where: PetScalarWhereInput;
  data: PetUpdateManyDataInput;
}

export interface AccountWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  status?: Maybe<AccountStatus>;
  status_not?: Maybe<AccountStatus>;
  status_in?: Maybe<AccountStatus[] | AccountStatus>;
  status_not_in?: Maybe<AccountStatus[] | AccountStatus>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  posts_every?: Maybe<PostWhereInput>;
  posts_some?: Maybe<PostWhereInput>;
  posts_none?: Maybe<PostWhereInput>;
  pets_every?: Maybe<PetWhereInput>;
  pets_some?: Maybe<PetWhereInput>;
  pets_none?: Maybe<PetWhereInput>;
  images_every?: Maybe<ImageWhereInput>;
  images_some?: Maybe<ImageWhereInput>;
  images_none?: Maybe<ImageWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  reviews_every?: Maybe<ReviewWhereInput>;
  reviews_some?: Maybe<ReviewWhereInput>;
  reviews_none?: Maybe<ReviewWhereInput>;
  petImages_every?: Maybe<PetImageWhereInput>;
  petImages_some?: Maybe<PetImageWhereInput>;
  petImages_none?: Maybe<PetImageWhereInput>;
  like_every?: Maybe<LikeWhereInput>;
  like_some?: Maybe<LikeWhereInput>;
  like_none?: Maybe<LikeWhereInput>;
  reports_every?: Maybe<ReportWhereInput>;
  reports_some?: Maybe<ReportWhereInput>;
  reports_none?: Maybe<ReportWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AccountWhereInput[] | AccountWhereInput>;
  OR?: Maybe<AccountWhereInput[] | AccountWhereInput>;
  NOT?: Maybe<AccountWhereInput[] | AccountWhereInput>;
}

export interface PetUpdateManyDataInput {
  type?: Maybe<PetType>;
  info?: Maybe<Json>;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface AccountUpsertWithoutCommentsInput {
  update: AccountUpdateWithoutCommentsDataInput;
  create: AccountCreateWithoutCommentsInput;
}

export interface AccountCreateWithoutUsersInput {
  id?: Maybe<UUID>;
  username: String;
  password: String;
  email: String;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  posts?: Maybe<PostCreateManyWithoutAccountInput>;
  pets?: Maybe<PetCreateManyWithoutAccountInput>;
  images?: Maybe<ImageCreateManyWithoutAccountInput>;
  comments?: Maybe<CommentCreateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewCreateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageCreateManyWithoutAccountInput>;
  like?: Maybe<LikeCreateManyWithoutAccountInput>;
  reports?: Maybe<ReportCreateManyWithoutCreatedByInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutPostDataInput;
  create: CommentCreateWithoutPostInput;
}

export interface PostTagUpdateWithWhereUniqueWithoutTagInput {
  where: PostTagWhereUniqueInput;
  data: PostTagUpdateWithoutTagDataInput;
}

export interface PostUpsertWithWhereUniqueWithoutAccountInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAccountDataInput;
  create: PostCreateWithoutAccountInput;
}

export interface ReviewUpsertNestedInput {
  update: ReviewUpdateDataInput;
  create: ReviewCreateInput;
}

export interface PostScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  dueDate?: Maybe<DateTimeInput>;
  dueDate_not?: Maybe<DateTimeInput>;
  dueDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dueDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dueDate_lt?: Maybe<DateTimeInput>;
  dueDate_lte?: Maybe<DateTimeInput>;
  dueDate_gt?: Maybe<DateTimeInput>;
  dueDate_gte?: Maybe<DateTimeInput>;
  status?: Maybe<PostStatus>;
  status_not?: Maybe<PostStatus>;
  status_in?: Maybe<PostStatus[] | PostStatus>;
  status_not_in?: Maybe<PostStatus[] | PostStatus>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  OR?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  NOT?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
}

export interface ReviewUpdateManyMutationInput {
  message?: Maybe<String>;
  stars?: Maybe<Int>;
  likes?: Maybe<Int>;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface ReportCreateInput {
  id?: Maybe<UUID>;
  reason: String;
  post: PostCreateOneWithoutReportsInput;
  createdBy: AccountCreateOneWithoutReportsInput;
}

export interface PostUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  location?: Maybe<String>;
  price?: Maybe<Int>;
  dueDate?: Maybe<DateTimeInput>;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
}

export interface PostCreateOneWithoutPostTagsInput {
  create?: Maybe<PostCreateWithoutPostTagsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface AccountUpsertWithoutImagesInput {
  update: AccountUpdateWithoutImagesDataInput;
  create: AccountCreateWithoutImagesInput;
}

export interface AccountUpsertWithoutPetImagesInput {
  update: AccountUpdateWithoutPetImagesDataInput;
  create: AccountCreateWithoutPetImagesInput;
}

export interface UserUpsertWithWhereUniqueWithoutAccountInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutAccountDataInput;
  create: UserCreateWithoutAccountInput;
}

export interface PetImageCreateInput {
  id?: Maybe<UUID>;
  image: ImageCreateOneInput;
  pet: PetCreateOneInput;
  account: AccountCreateOneWithoutPetImagesInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  dob_not?: Maybe<DateTimeInput>;
  dob_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dob_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dob_lt?: Maybe<DateTimeInput>;
  dob_lte?: Maybe<DateTimeInput>;
  dob_gt?: Maybe<DateTimeInput>;
  dob_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface ImageCreateInput {
  id?: Maybe<UUID>;
  publicId: String;
  url: String;
  account: AccountCreateOneWithoutImagesInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface TagCreateWithoutPostTagsInput {
  id?: Maybe<UUID>;
  title: String;
  description?: Maybe<String>;
}

export interface UserUpdateManyDataInput {
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  address?: Maybe<Json>;
  bio?: Maybe<String>;
  dob?: Maybe<DateTimeInput>;
  settings?: Maybe<Json>;
}

export interface PostCreateInput {
  id?: Maybe<UUID>;
  title: String;
  description?: Maybe<String>;
  location: String;
  price?: Maybe<Int>;
  dueDate: DateTimeInput;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  postTags?: Maybe<PostTagCreateManyWithoutPostInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  reviews?: Maybe<ReviewCreateManyWithoutPostInput>;
  reports?: Maybe<ReportCreateManyWithoutPostInput>;
  account: AccountCreateOneWithoutPostsInput;
}

export interface AccountUpdateManyMutationInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
}

export interface CommentCreateWithoutCreatedByInput {
  id?: Maybe<UUID>;
  message: String;
  image?: Maybe<ImageCreateOneInput>;
  likes?: Maybe<Int>;
  post: PostCreateOneWithoutCommentsInput;
}

export interface ImageUpdateManyMutationInput {
  publicId?: Maybe<String>;
  url?: Maybe<String>;
}

export interface ReviewCreateWithoutCreatedByInput {
  id?: Maybe<UUID>;
  message: String;
  stars: Int;
  image?: Maybe<ImageCreateOneInput>;
  likes?: Maybe<Int>;
  post: PostCreateOneWithoutReviewsInput;
}

export interface ImageUpdateInput {
  publicId?: Maybe<String>;
  url?: Maybe<String>;
  account?: Maybe<AccountUpdateOneRequiredWithoutImagesInput>;
}

export interface PetCreateInput {
  id?: Maybe<UUID>;
  type: PetType;
  info?: Maybe<Json>;
  post: PostCreateOneInput;
  account: AccountCreateOneWithoutPetsInput;
}

export interface CommentCreateInput {
  id?: Maybe<UUID>;
  message: String;
  image?: Maybe<ImageCreateOneInput>;
  likes?: Maybe<Int>;
  post: PostCreateOneWithoutCommentsInput;
  createdBy: AccountCreateOneWithoutCommentsInput;
}

export interface ReviewLikeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReviewLikeWhereInput>;
  AND?: Maybe<ReviewLikeSubscriptionWhereInput[] | ReviewLikeSubscriptionWhereInput>;
  OR?: Maybe<ReviewLikeSubscriptionWhereInput[] | ReviewLikeSubscriptionWhereInput>;
  NOT?: Maybe<ReviewLikeSubscriptionWhereInput[] | ReviewLikeSubscriptionWhereInput>;
}

export interface CommentUpdateInput {
  message?: Maybe<String>;
  image?: Maybe<ImageUpdateOneInput>;
  likes?: Maybe<Int>;
  post?: Maybe<PostUpdateOneRequiredWithoutCommentsInput>;
  createdBy?: Maybe<AccountUpdateOneRequiredWithoutCommentsInput>;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImageWhereInput>;
  AND?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  OR?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  NOT?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
}

export interface CommentUpdateManyMutationInput {
  message?: Maybe<String>;
  likes?: Maybe<Int>;
}

export interface TagUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
}

export interface CommentLikeCreateInput {
  id?: Maybe<UUID>;
  comment: CommentCreateOneInput;
  like: LikeCreateOneInput;
}

export interface ReviewLikeUpdateInput {
  review?: Maybe<ReviewUpdateOneRequiredInput>;
  like?: Maybe<LikeUpdateOneRequiredInput>;
}

export interface CommentCreateOneInput {
  create?: Maybe<CommentCreateInput>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface PostUpdateOneRequiredWithoutPostTagsInput {
  create?: Maybe<PostCreateWithoutPostTagsInput>;
  update?: Maybe<PostUpdateWithoutPostTagsDataInput>;
  upsert?: Maybe<PostUpsertWithoutPostTagsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface LikeCreateOneInput {
  create?: Maybe<LikeCreateInput>;
  connect?: Maybe<LikeWhereUniqueInput>;
}

export interface PetImageUpdateInput {
  image?: Maybe<ImageUpdateOneRequiredInput>;
  pet?: Maybe<PetUpdateOneRequiredInput>;
  account?: Maybe<AccountUpdateOneRequiredWithoutPetImagesInput>;
}

export interface LikeCreateInput {
  id?: Maybe<UUID>;
  count?: Maybe<Int>;
  account: AccountCreateOneWithoutLikeInput;
}

export interface PostCreateWithoutAccountInput {
  id?: Maybe<UUID>;
  title: String;
  description?: Maybe<String>;
  location: String;
  price?: Maybe<Int>;
  dueDate: DateTimeInput;
  settings?: Maybe<Json>;
  status?: Maybe<PostStatus>;
  postTags?: Maybe<PostTagCreateManyWithoutPostInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  reviews?: Maybe<ReviewCreateManyWithoutPostInput>;
  reports?: Maybe<ReportCreateManyWithoutPostInput>;
}

export interface AccountCreateOneWithoutLikeInput {
  create?: Maybe<AccountCreateWithoutLikeInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface AccountCreateWithoutReviewsInput {
  id?: Maybe<UUID>;
  username: String;
  password: String;
  email: String;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserCreateManyWithoutAccountInput>;
  posts?: Maybe<PostCreateManyWithoutAccountInput>;
  pets?: Maybe<PetCreateManyWithoutAccountInput>;
  images?: Maybe<ImageCreateManyWithoutAccountInput>;
  comments?: Maybe<CommentCreateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageCreateManyWithoutAccountInput>;
  like?: Maybe<LikeCreateManyWithoutAccountInput>;
  reports?: Maybe<ReportCreateManyWithoutCreatedByInput>;
}

export interface AccountCreateWithoutLikeInput {
  id?: Maybe<UUID>;
  username: String;
  password: String;
  email: String;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserCreateManyWithoutAccountInput>;
  posts?: Maybe<PostCreateManyWithoutAccountInput>;
  pets?: Maybe<PetCreateManyWithoutAccountInput>;
  images?: Maybe<ImageCreateManyWithoutAccountInput>;
  comments?: Maybe<CommentCreateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewCreateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageCreateManyWithoutAccountInput>;
  reports?: Maybe<ReportCreateManyWithoutCreatedByInput>;
}

export interface AccountCreateWithoutPostsInput {
  id?: Maybe<UUID>;
  username: String;
  password: String;
  email: String;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserCreateManyWithoutAccountInput>;
  pets?: Maybe<PetCreateManyWithoutAccountInput>;
  images?: Maybe<ImageCreateManyWithoutAccountInput>;
  comments?: Maybe<CommentCreateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewCreateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageCreateManyWithoutAccountInput>;
  like?: Maybe<LikeCreateManyWithoutAccountInput>;
  reports?: Maybe<ReportCreateManyWithoutCreatedByInput>;
}

export interface CommentLikeUpdateInput {
  comment?: Maybe<CommentUpdateOneRequiredInput>;
  like?: Maybe<LikeUpdateOneRequiredInput>;
}

export interface PostLikeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostLikeWhereInput>;
  AND?: Maybe<PostLikeSubscriptionWhereInput[] | PostLikeSubscriptionWhereInput>;
  OR?: Maybe<PostLikeSubscriptionWhereInput[] | PostLikeSubscriptionWhereInput>;
  NOT?: Maybe<PostLikeSubscriptionWhereInput[] | PostLikeSubscriptionWhereInput>;
}

export interface CommentUpdateOneRequiredInput {
  create?: Maybe<CommentCreateInput>;
  update?: Maybe<CommentUpdateDataInput>;
  upsert?: Maybe<CommentUpsertNestedInput>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface PostTagCreateWithoutTagInput {
  id?: Maybe<UUID>;
  post: PostCreateOneWithoutPostTagsInput;
}

export interface CommentUpdateDataInput {
  message?: Maybe<String>;
  image?: Maybe<ImageUpdateOneInput>;
  likes?: Maybe<Int>;
  post?: Maybe<PostUpdateOneRequiredWithoutCommentsInput>;
  createdBy?: Maybe<AccountUpdateOneRequiredWithoutCommentsInput>;
}

export interface ReviewLikeWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  review?: Maybe<ReviewWhereInput>;
  like?: Maybe<LikeWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReviewLikeWhereInput[] | ReviewLikeWhereInput>;
  OR?: Maybe<ReviewLikeWhereInput[] | ReviewLikeWhereInput>;
  NOT?: Maybe<ReviewLikeWhereInput[] | ReviewLikeWhereInput>;
}

export interface CommentUpsertNestedInput {
  update: CommentUpdateDataInput;
  create: CommentCreateInput;
}

export interface AccountCreateWithoutCommentsInput {
  id?: Maybe<UUID>;
  username: String;
  password: String;
  email: String;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserCreateManyWithoutAccountInput>;
  posts?: Maybe<PostCreateManyWithoutAccountInput>;
  pets?: Maybe<PetCreateManyWithoutAccountInput>;
  images?: Maybe<ImageCreateManyWithoutAccountInput>;
  reviews?: Maybe<ReviewCreateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageCreateManyWithoutAccountInput>;
  like?: Maybe<LikeCreateManyWithoutAccountInput>;
  reports?: Maybe<ReportCreateManyWithoutCreatedByInput>;
}

export interface LikeUpdateOneRequiredInput {
  create?: Maybe<LikeCreateInput>;
  update?: Maybe<LikeUpdateDataInput>;
  upsert?: Maybe<LikeUpsertNestedInput>;
  connect?: Maybe<LikeWhereUniqueInput>;
}

export interface LikeCreateWithoutAccountInput {
  id?: Maybe<UUID>;
  count?: Maybe<Int>;
}

export interface AccountUpsertWithoutLikeInput {
  update: AccountUpdateWithoutLikeDataInput;
  create: AccountCreateWithoutLikeInput;
}

export interface AccountUpdateWithoutLikeDataInput {
  username?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserUpdateManyWithoutAccountInput>;
  posts?: Maybe<PostUpdateManyWithoutAccountInput>;
  pets?: Maybe<PetUpdateManyWithoutAccountInput>;
  images?: Maybe<ImageUpdateManyWithoutAccountInput>;
  comments?: Maybe<CommentUpdateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewUpdateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageUpdateManyWithoutAccountInput>;
  reports?: Maybe<ReportUpdateManyWithoutCreatedByInput>;
}

export interface AccountUpdateOneRequiredWithoutLikeInput {
  create?: Maybe<AccountCreateWithoutLikeInput>;
  update?: Maybe<AccountUpdateWithoutLikeDataInput>;
  upsert?: Maybe<AccountUpsertWithoutLikeInput>;
  connect?: Maybe<AccountWhereUniqueInput>;
}

export interface LikeUpdateDataInput {
  count?: Maybe<Int>;
  account?: Maybe<AccountUpdateOneRequiredWithoutLikeInput>;
}

export type CommentLikeWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface ReportCreateWithoutPostInput {
  id?: Maybe<UUID>;
  reason: String;
  createdBy: AccountCreateOneWithoutReportsInput;
}

export interface AccountCreateInput {
  id?: Maybe<UUID>;
  username: String;
  password: String;
  email: String;
  role?: Maybe<Role>;
  status?: Maybe<AccountStatus>;
  settings?: Maybe<Json>;
  users?: Maybe<UserCreateManyWithoutAccountInput>;
  posts?: Maybe<PostCreateManyWithoutAccountInput>;
  pets?: Maybe<PetCreateManyWithoutAccountInput>;
  images?: Maybe<ImageCreateManyWithoutAccountInput>;
  comments?: Maybe<CommentCreateManyWithoutCreatedByInput>;
  reviews?: Maybe<ReviewCreateManyWithoutCreatedByInput>;
  petImages?: Maybe<PetImageCreateManyWithoutAccountInput>;
  like?: Maybe<LikeCreateManyWithoutAccountInput>;
  reports?: Maybe<ReportCreateManyWithoutCreatedByInput>;
}

export interface ReviewCreateInput {
  id?: Maybe<UUID>;
  message: String;
  stars: Int;
  image?: Maybe<ImageCreateOneInput>;
  likes?: Maybe<Int>;
  post: PostCreateOneWithoutReviewsInput;
  createdBy: AccountCreateOneWithoutReviewsInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: UUID;
  name: String;
  phoneNumber: String;
  address: Json;
  bio?: String;
  dob?: DateTimeOutput;
  settings?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise extends Promise<UserPreviousValues>, Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  address: () => Promise<Json>;
  bio: () => Promise<String>;
  dob: () => Promise<DateTimeOutput>;
  settings: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<Json>>;
  bio: () => Promise<AsyncIterator<String>>;
  dob: () => Promise<AsyncIterator<DateTimeOutput>>;
  settings: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentLike {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentLikePromise extends Promise<CommentLike>, Fragmentable {
  id: () => Promise<UUID>;
  comment: <T = CommentPromise>() => T;
  like: <T = LikePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentLikeSubscription extends Promise<AsyncIterator<CommentLike>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  comment: <T = CommentSubscription>() => T;
  like: <T = LikeSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentLikeNullablePromise extends Promise<CommentLike | null>, Fragmentable {
  id: () => Promise<UUID>;
  comment: <T = CommentPromise>() => T;
  like: <T = LikePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface User {
  id: UUID;
  name: String;
  phoneNumber: String;
  address: Json;
  bio?: String;
  dob?: DateTimeOutput;
  settings?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  address: () => Promise<Json>;
  bio: () => Promise<String>;
  dob: () => Promise<DateTimeOutput>;
  avatar: <T = ImagePromise>() => T;
  settings: () => Promise<Json>;
  account: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription extends Promise<AsyncIterator<User>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<Json>>;
  bio: () => Promise<AsyncIterator<String>>;
  dob: () => Promise<AsyncIterator<DateTimeOutput>>;
  avatar: <T = ImageSubscription>() => T;
  settings: () => Promise<AsyncIterator<Json>>;
  account: <T = AccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise extends Promise<User | null>, Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  address: () => Promise<Json>;
  bio: () => Promise<String>;
  dob: () => Promise<DateTimeOutput>;
  avatar: <T = ImagePromise>() => T;
  settings: () => Promise<Json>;
  account: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise extends Promise<AggregateComment>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Image {
  id: UUID;
  publicId: String;
  url: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<UUID>;
  publicId: () => Promise<String>;
  url: () => Promise<String>;
  account: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImageSubscription extends Promise<AsyncIterator<Image>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  publicId: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  account: <T = AccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ImageNullablePromise extends Promise<Image | null>, Fragmentable {
  id: () => Promise<UUID>;
  publicId: () => Promise<String>;
  url: () => Promise<String>;
  account: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Post {
  id: UUID;
  title: String;
  description?: String;
  location: String;
  price: Int;
  dueDate: DateTimeOutput;
  settings?: Json;
  status: PostStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<UUID>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  location: () => Promise<String>;
  price: () => Promise<Int>;
  dueDate: () => Promise<DateTimeOutput>;
  settings: () => Promise<Json>;
  status: () => Promise<PostStatus>;
  postTags: <T = FragmentableArray<PostTag>>(args?: {
    where?: PostTagWhereInput;
    orderBy?: PostTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  account: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostSubscription extends Promise<AsyncIterator<Post>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  dueDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  settings: () => Promise<AsyncIterator<Json>>;
  status: () => Promise<AsyncIterator<PostStatus>>;
  postTags: <T = Promise<AsyncIterator<PostTagSubscription>>>(args?: {
    where?: PostTagWhereInput;
    orderBy?: PostTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = Promise<AsyncIterator<ReportSubscription>>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  account: <T = AccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostNullablePromise extends Promise<Post | null>, Fragmentable {
  id: () => Promise<UUID>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  location: () => Promise<String>;
  price: () => Promise<Int>;
  dueDate: () => Promise<DateTimeOutput>;
  settings: () => Promise<Json>;
  status: () => Promise<PostStatus>;
  postTags: <T = FragmentableArray<PostTag>>(args?: {
    where?: PostTagWhereInput;
    orderBy?: PostTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  account: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReviewLikeSubscriptionPayload {
  mutation: MutationType;
  node: ReviewLike;
  updatedFields: String[];
  previousValues: ReviewLikePreviousValues;
}

export interface ReviewLikeSubscriptionPayloadPromise
  extends Promise<ReviewLikeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReviewLikePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewLikePreviousValuesPromise>() => T;
}

export interface ReviewLikeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewLikeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewLikeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewLikePreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise extends Promise<BatchPayload>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription extends Promise<AsyncIterator<CommentEdge>>, Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TagPreviousValues {
  id: UUID;
  title: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TagPreviousValuesPromise extends Promise<TagPreviousValues>, Fragmentable {
  id: () => Promise<UUID>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise extends Promise<UserConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise extends Promise<AggregateUser>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription extends Promise<AsyncIterator<TagEdge>>, Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise extends Promise<CommentConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface Account {
  id: UUID;
  username: String;
  password: String;
  email: String;
  role: Role;
  status?: AccountStatus;
  settings?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AccountPromise extends Promise<Account>, Fragmentable {
  id: () => Promise<UUID>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  status: () => Promise<AccountStatus>;
  settings: () => Promise<Json>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pets: <T = FragmentableArray<Pet>>(args?: {
    where?: PetWhereInput;
    orderBy?: PetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  petImages: <T = FragmentableArray<PetImage>>(args?: {
    where?: PetImageWhereInput;
    orderBy?: PetImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  like: <T = FragmentableArray<Like>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AccountSubscription extends Promise<AsyncIterator<Account>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  status: () => Promise<AsyncIterator<AccountStatus>>;
  settings: () => Promise<AsyncIterator<Json>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pets: <T = Promise<AsyncIterator<PetSubscription>>>(args?: {
    where?: PetWhereInput;
    orderBy?: PetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  petImages: <T = Promise<AsyncIterator<PetImageSubscription>>>(args?: {
    where?: PetImageWhereInput;
    orderBy?: PetImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  like: <T = Promise<AsyncIterator<LikeSubscription>>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = Promise<AsyncIterator<ReportSubscription>>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AccountNullablePromise extends Promise<Account | null>, Fragmentable {
  id: () => Promise<UUID>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  status: () => Promise<AccountStatus>;
  settings: () => Promise<Json>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pets: <T = FragmentableArray<Pet>>(args?: {
    where?: PetWhereInput;
    orderBy?: PetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  petImages: <T = FragmentableArray<PetImage>>(args?: {
    where?: PetImageWhereInput;
    orderBy?: PetImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  like: <T = FragmentableArray<Like>>(args?: {
    where?: LikeWhereInput;
    orderBy?: LikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reports: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateAccount {
  count: Int;
}

export interface AggregateAccountPromise extends Promise<AggregateAccount>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccountSubscription
  extends Promise<AsyncIterator<AggregateAccount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewLikeEdge {
  node: ReviewLike;
  cursor: String;
}

export interface ReviewLikeEdgePromise extends Promise<ReviewLikeEdge>, Fragmentable {
  node: <T = ReviewLikePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewLikeEdgeSubscription
  extends Promise<AsyncIterator<ReviewLikeEdge>>,
    Fragmentable {
  node: <T = ReviewLikeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AccountSubscriptionPayload {
  mutation: MutationType;
  node: Account;
  updatedFields: String[];
  previousValues: AccountPreviousValues;
}

export interface AccountSubscriptionPayloadPromise
  extends Promise<AccountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccountPreviousValuesPromise>() => T;
}

export interface AccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccountPreviousValuesSubscription>() => T;
}

export interface AggregateReview {
  count: Int;
}

export interface AggregateReviewPromise extends Promise<AggregateReview>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AccountPreviousValues {
  id: UUID;
  username: String;
  password: String;
  email: String;
  role: Role;
  status?: AccountStatus;
  settings?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AccountPreviousValuesPromise extends Promise<AccountPreviousValues>, Fragmentable {
  id: () => Promise<UUID>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  status: () => Promise<AccountStatus>;
  settings: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AccountPreviousValuesSubscription
  extends Promise<AsyncIterator<AccountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  status: () => Promise<AsyncIterator<AccountStatus>>;
  settings: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewConnection {
  pageInfo: PageInfo;
  edges: ReviewEdge[];
}

export interface ReviewConnectionPromise extends Promise<ReviewConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReviewEdge>>() => T;
  aggregate: <T = AggregateReviewPromise>() => T;
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewSubscription>() => T;
}

export interface AccountEdge {
  node: Account;
  cursor: String;
}

export interface AccountEdgePromise extends Promise<AccountEdge>, Fragmentable {
  node: <T = AccountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccountEdgeSubscription extends Promise<AsyncIterator<AccountEdge>>, Fragmentable {
  node: <T = AccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReportEdge {
  node: Report;
  cursor: String;
}

export interface ReportEdgePromise extends Promise<ReportEdge>, Fragmentable {
  node: <T = ReportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReportEdgeSubscription extends Promise<AsyncIterator<ReportEdge>>, Fragmentable {
  node: <T = ReportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface AggregatePostTag {
  count: Int;
}

export interface AggregatePostTagPromise extends Promise<AggregatePostTag>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostTagSubscription
  extends Promise<AsyncIterator<AggregatePostTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentPreviousValues {
  id: UUID;
  message: String;
  likes: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPreviousValuesPromise extends Promise<CommentPreviousValues>, Fragmentable {
  id: () => Promise<UUID>;
  message: () => Promise<String>;
  likes: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  message: () => Promise<AsyncIterator<String>>;
  likes: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostTagConnection {
  pageInfo: PageInfo;
  edges: PostTagEdge[];
}

export interface PostTagConnectionPromise extends Promise<PostTagConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostTagEdge>>() => T;
  aggregate: <T = AggregatePostTagPromise>() => T;
}

export interface PostTagConnectionSubscription
  extends Promise<AsyncIterator<PostTagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostTagEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostTagSubscription>() => T;
}

export interface PostTag {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostTagPromise extends Promise<PostTag>, Fragmentable {
  id: () => Promise<UUID>;
  post: <T = PostPromise>() => T;
  tag: <T = TagPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostTagSubscription extends Promise<AsyncIterator<PostTag>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  post: <T = PostSubscription>() => T;
  tag: <T = TagSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostTagNullablePromise extends Promise<PostTag | null>, Fragmentable {
  id: () => Promise<UUID>;
  post: <T = PostPromise>() => T;
  tag: <T = TagPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostLikeEdge {
  node: PostLike;
  cursor: String;
}

export interface PostLikeEdgePromise extends Promise<PostLikeEdge>, Fragmentable {
  node: <T = PostLikePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostLikeEdgeSubscription
  extends Promise<AsyncIterator<PostLikeEdge>>,
    Fragmentable {
  node: <T = PostLikeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentLikeSubscriptionPayload {
  mutation: MutationType;
  node: CommentLike;
  updatedFields: String[];
  previousValues: CommentLikePreviousValues;
}

export interface CommentLikeSubscriptionPayloadPromise
  extends Promise<CommentLikeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentLikePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentLikePreviousValuesPromise>() => T;
}

export interface CommentLikeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentLikeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentLikeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentLikePreviousValuesSubscription>() => T;
}

export interface PostLike {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostLikePromise extends Promise<PostLike>, Fragmentable {
  id: () => Promise<UUID>;
  post: <T = PostPromise>() => T;
  like: <T = LikePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostLikeSubscription extends Promise<AsyncIterator<PostLike>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  post: <T = PostSubscription>() => T;
  like: <T = LikeSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostLikeNullablePromise extends Promise<PostLike | null>, Fragmentable {
  id: () => Promise<UUID>;
  post: <T = PostPromise>() => T;
  like: <T = LikePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentLikePreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentLikePreviousValuesPromise
  extends Promise<CommentLikePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentLikePreviousValuesSubscription
  extends Promise<AsyncIterator<CommentLikePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription extends Promise<AsyncIterator<PostEdge>>, Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription extends Promise<AsyncIterator<PageInfo>>, Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePetImage {
  count: Int;
}

export interface AggregatePetImagePromise extends Promise<AggregatePetImage>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePetImageSubscription
  extends Promise<AsyncIterator<AggregatePetImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface PetImageConnection {
  pageInfo: PageInfo;
  edges: PetImageEdge[];
}

export interface PetImageConnectionPromise extends Promise<PetImageConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PetImageEdge>>() => T;
  aggregate: <T = AggregatePetImagePromise>() => T;
}

export interface PetImageConnectionSubscription
  extends Promise<AsyncIterator<PetImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PetImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePetImageSubscription>() => T;
}

export interface ImagePreviousValues {
  id: UUID;
  publicId: String;
  url: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ImagePreviousValuesPromise extends Promise<ImagePreviousValues>, Fragmentable {
  id: () => Promise<UUID>;
  publicId: () => Promise<String>;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  publicId: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PetEdge {
  node: Pet;
  cursor: String;
}

export interface PetEdgePromise extends Promise<PetEdge>, Fragmentable {
  node: <T = PetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PetEdgeSubscription extends Promise<AsyncIterator<PetEdge>>, Fragmentable {
  node: <T = PetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AccountConnection {
  pageInfo: PageInfo;
  edges: AccountEdge[];
}

export interface AccountConnectionPromise extends Promise<AccountConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccountEdge>>() => T;
  aggregate: <T = AggregateAccountPromise>() => T;
}

export interface AccountConnectionSubscription
  extends Promise<AsyncIterator<AccountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAccountSubscription>() => T;
}

export interface AggregateLike {
  count: Int;
}

export interface AggregateLikePromise extends Promise<AggregateLike>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLikeSubscription
  extends Promise<AsyncIterator<AggregateLike>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LikeSubscriptionPayload {
  mutation: MutationType;
  node: Like;
  updatedFields: String[];
  previousValues: LikePreviousValues;
}

export interface LikeSubscriptionPayloadPromise
  extends Promise<LikeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LikePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LikePreviousValuesPromise>() => T;
}

export interface LikeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LikeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LikeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LikePreviousValuesSubscription>() => T;
}

export interface LikeConnection {
  pageInfo: PageInfo;
  edges: LikeEdge[];
}

export interface LikeConnectionPromise extends Promise<LikeConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LikeEdge>>() => T;
  aggregate: <T = AggregateLikePromise>() => T;
}

export interface LikeConnectionSubscription
  extends Promise<AsyncIterator<LikeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LikeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLikeSubscription>() => T;
}

export interface LikePreviousValues {
  id: UUID;
  count: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LikePreviousValuesPromise extends Promise<LikePreviousValues>, Fragmentable {
  id: () => Promise<UUID>;
  count: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LikePreviousValuesSubscription
  extends Promise<AsyncIterator<LikePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  count: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription extends Promise<AsyncIterator<ImageEdge>>, Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Like {
  id: UUID;
  count: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LikePromise extends Promise<Like>, Fragmentable {
  id: () => Promise<UUID>;
  count: () => Promise<Int>;
  account: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LikeSubscription extends Promise<AsyncIterator<Like>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  count: () => Promise<AsyncIterator<Int>>;
  account: <T = AccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LikeNullablePromise extends Promise<Like | null>, Fragmentable {
  id: () => Promise<UUID>;
  count: () => Promise<Int>;
  account: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateCommentLike {
  count: Int;
}

export interface AggregateCommentLikePromise extends Promise<AggregateCommentLike>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentLikeSubscription
  extends Promise<AsyncIterator<AggregateCommentLike>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PetSubscriptionPayload {
  mutation: MutationType;
  node: Pet;
  updatedFields: String[];
  previousValues: PetPreviousValues;
}

export interface PetSubscriptionPayloadPromise
  extends Promise<PetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PetPreviousValuesPromise>() => T;
}

export interface PetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PetPreviousValuesSubscription>() => T;
}

export interface CommentLikeConnection {
  pageInfo: PageInfo;
  edges: CommentLikeEdge[];
}

export interface CommentLikeConnectionPromise extends Promise<CommentLikeConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentLikeEdge>>() => T;
  aggregate: <T = AggregateCommentLikePromise>() => T;
}

export interface CommentLikeConnectionSubscription
  extends Promise<AsyncIterator<CommentLikeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentLikeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentLikeSubscription>() => T;
}

export interface PetPreviousValues {
  id: UUID;
  type: PetType;
  info?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PetPreviousValuesPromise extends Promise<PetPreviousValues>, Fragmentable {
  id: () => Promise<UUID>;
  type: () => Promise<PetType>;
  info: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PetPreviousValuesSubscription
  extends Promise<AsyncIterator<PetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  type: () => Promise<AsyncIterator<PetType>>;
  info: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise extends Promise<AggregateTag>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PetImage {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PetImagePromise extends Promise<PetImage>, Fragmentable {
  id: () => Promise<UUID>;
  image: <T = ImagePromise>() => T;
  pet: <T = PetPromise>() => T;
  account: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PetImageSubscription extends Promise<AsyncIterator<PetImage>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  image: <T = ImageSubscription>() => T;
  pet: <T = PetSubscription>() => T;
  account: <T = AccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PetImageNullablePromise extends Promise<PetImage | null>, Fragmentable {
  id: () => Promise<UUID>;
  image: <T = ImagePromise>() => T;
  pet: <T = PetPromise>() => T;
  account: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateReviewLike {
  count: Int;
}

export interface AggregateReviewLikePromise extends Promise<AggregateReviewLike>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewLikeSubscription
  extends Promise<AsyncIterator<AggregateReviewLike>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PetImageSubscriptionPayload {
  mutation: MutationType;
  node: PetImage;
  updatedFields: String[];
  previousValues: PetImagePreviousValues;
}

export interface PetImageSubscriptionPayloadPromise
  extends Promise<PetImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PetImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PetImagePreviousValuesPromise>() => T;
}

export interface PetImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PetImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PetImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PetImagePreviousValuesSubscription>() => T;
}

export interface ReviewLike {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReviewLikePromise extends Promise<ReviewLike>, Fragmentable {
  id: () => Promise<UUID>;
  review: <T = ReviewPromise>() => T;
  like: <T = LikePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReviewLikeSubscription extends Promise<AsyncIterator<ReviewLike>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  review: <T = ReviewSubscription>() => T;
  like: <T = LikeSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewLikeNullablePromise extends Promise<ReviewLike | null>, Fragmentable {
  id: () => Promise<UUID>;
  review: <T = ReviewPromise>() => T;
  like: <T = LikePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PetImagePreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PetImagePreviousValuesPromise
  extends Promise<PetImagePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PetImagePreviousValuesSubscription
  extends Promise<AsyncIterator<PetImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateReport {
  count: Int;
}

export interface AggregateReportPromise extends Promise<AggregateReport>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReportSubscription
  extends Promise<AsyncIterator<AggregateReport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewLikePreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReviewLikePreviousValuesPromise
  extends Promise<ReviewLikePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReviewLikePreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewLikePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostTagEdge {
  node: PostTag;
  cursor: String;
}

export interface PostTagEdgePromise extends Promise<PostTagEdge>, Fragmentable {
  node: <T = PostTagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostTagEdgeSubscription extends Promise<AsyncIterator<PostTagEdge>>, Fragmentable {
  node: <T = PostTagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface PostLikeConnection {
  pageInfo: PageInfo;
  edges: PostLikeEdge[];
}

export interface PostLikeConnectionPromise extends Promise<PostLikeConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostLikeEdge>>() => T;
  aggregate: <T = AggregatePostLikePromise>() => T;
}

export interface PostLikeConnectionSubscription
  extends Promise<AsyncIterator<PostLikeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostLikeEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostLikeSubscription>() => T;
}

export interface PostPreviousValues {
  id: UUID;
  title: String;
  description?: String;
  location: String;
  price: Int;
  dueDate: DateTimeOutput;
  settings?: Json;
  status: PostStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostPreviousValuesPromise extends Promise<PostPreviousValues>, Fragmentable {
  id: () => Promise<UUID>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  location: () => Promise<String>;
  price: () => Promise<Int>;
  dueDate: () => Promise<DateTimeOutput>;
  settings: () => Promise<Json>;
  status: () => Promise<PostStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  dueDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  settings: () => Promise<AsyncIterator<Json>>;
  status: () => Promise<AsyncIterator<PostStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise extends Promise<PostConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface Pet {
  id: UUID;
  type: PetType;
  info?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PetPromise extends Promise<Pet>, Fragmentable {
  id: () => Promise<UUID>;
  type: () => Promise<PetType>;
  info: () => Promise<Json>;
  post: <T = PostPromise>() => T;
  account: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PetSubscription extends Promise<AsyncIterator<Pet>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  type: () => Promise<AsyncIterator<PetType>>;
  info: () => Promise<AsyncIterator<Json>>;
  post: <T = PostSubscription>() => T;
  account: <T = AccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PetNullablePromise extends Promise<Pet | null>, Fragmentable {
  id: () => Promise<UUID>;
  type: () => Promise<PetType>;
  info: () => Promise<Json>;
  post: <T = PostPromise>() => T;
  account: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregatePet {
  count: Int;
}

export interface AggregatePetPromise extends Promise<AggregatePet>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePetSubscription
  extends Promise<AsyncIterator<AggregatePet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostLikeSubscriptionPayload {
  mutation: MutationType;
  node: PostLike;
  updatedFields: String[];
  previousValues: PostLikePreviousValues;
}

export interface PostLikeSubscriptionPayloadPromise
  extends Promise<PostLikeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostLikePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostLikePreviousValuesPromise>() => T;
}

export interface PostLikeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostLikeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostLikeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostLikePreviousValuesSubscription>() => T;
}

export interface LikeEdge {
  node: Like;
  cursor: String;
}

export interface LikeEdgePromise extends Promise<LikeEdge>, Fragmentable {
  node: <T = LikePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LikeEdgeSubscription extends Promise<AsyncIterator<LikeEdge>>, Fragmentable {
  node: <T = LikeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostLikePreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostLikePreviousValuesPromise
  extends Promise<PostLikePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostLikePreviousValuesSubscription
  extends Promise<AsyncIterator<PostLikePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise extends Promise<ImageConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface Report {
  id: UUID;
  reason: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReportPromise extends Promise<Report>, Fragmentable {
  id: () => Promise<UUID>;
  reason: () => Promise<String>;
  post: <T = PostPromise>() => T;
  createdBy: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReportSubscription extends Promise<AsyncIterator<Report>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  reason: () => Promise<AsyncIterator<String>>;
  post: <T = PostSubscription>() => T;
  createdBy: <T = AccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReportNullablePromise extends Promise<Report | null>, Fragmentable {
  id: () => Promise<UUID>;
  reason: () => Promise<String>;
  post: <T = PostPromise>() => T;
  createdBy: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription extends Promise<AsyncIterator<UserEdge>>, Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostTagSubscriptionPayload {
  mutation: MutationType;
  node: PostTag;
  updatedFields: String[];
  previousValues: PostTagPreviousValues;
}

export interface PostTagSubscriptionPayloadPromise
  extends Promise<PostTagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostTagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostTagPreviousValuesPromise>() => T;
}

export interface PostTagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostTagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostTagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostTagPreviousValuesSubscription>() => T;
}

export interface ReviewLikeConnection {
  pageInfo: PageInfo;
  edges: ReviewLikeEdge[];
}

export interface ReviewLikeConnectionPromise extends Promise<ReviewLikeConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReviewLikeEdge>>() => T;
  aggregate: <T = AggregateReviewLikePromise>() => T;
}

export interface ReviewLikeConnectionSubscription
  extends Promise<AsyncIterator<ReviewLikeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewLikeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewLikeSubscription>() => T;
}

export interface PostTagPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostTagPreviousValuesPromise extends Promise<PostTagPreviousValues>, Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostTagPreviousValuesSubscription
  extends Promise<AsyncIterator<PostTagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReportConnection {
  pageInfo: PageInfo;
  edges: ReportEdge[];
}

export interface ReportConnectionPromise extends Promise<ReportConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReportEdge>>() => T;
  aggregate: <T = AggregateReportPromise>() => T;
}

export interface ReportConnectionSubscription
  extends Promise<AsyncIterator<ReportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReportEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReportSubscription>() => T;
}

export interface Review {
  id: UUID;
  message: String;
  stars: Int;
  likes: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReviewPromise extends Promise<Review>, Fragmentable {
  id: () => Promise<UUID>;
  message: () => Promise<String>;
  stars: () => Promise<Int>;
  image: <T = ImagePromise>() => T;
  likes: () => Promise<Int>;
  post: <T = PostPromise>() => T;
  createdBy: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReviewSubscription extends Promise<AsyncIterator<Review>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  message: () => Promise<AsyncIterator<String>>;
  stars: () => Promise<AsyncIterator<Int>>;
  image: <T = ImageSubscription>() => T;
  likes: () => Promise<AsyncIterator<Int>>;
  post: <T = PostSubscription>() => T;
  createdBy: <T = AccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewNullablePromise extends Promise<Review | null>, Fragmentable {
  id: () => Promise<UUID>;
  message: () => Promise<String>;
  stars: () => Promise<Int>;
  image: <T = ImagePromise>() => T;
  likes: () => Promise<Int>;
  post: <T = PostPromise>() => T;
  createdBy: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise extends Promise<AggregatePost>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReportSubscriptionPayload {
  mutation: MutationType;
  node: Report;
  updatedFields: String[];
  previousValues: ReportPreviousValues;
}

export interface ReportSubscriptionPayloadPromise
  extends Promise<ReportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReportPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReportPreviousValuesPromise>() => T;
}

export interface ReportSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReportSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReportPreviousValuesSubscription>() => T;
}

export interface PetConnection {
  pageInfo: PageInfo;
  edges: PetEdge[];
}

export interface PetConnectionPromise extends Promise<PetConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PetEdge>>() => T;
  aggregate: <T = AggregatePetPromise>() => T;
}

export interface PetConnectionSubscription
  extends Promise<AsyncIterator<PetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PetEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePetSubscription>() => T;
}

export interface ReportPreviousValues {
  id: UUID;
  reason: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReportPreviousValuesPromise extends Promise<ReportPreviousValues>, Fragmentable {
  id: () => Promise<UUID>;
  reason: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReportPreviousValuesSubscription
  extends Promise<AsyncIterator<ReportPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  reason: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentLikeEdge {
  node: CommentLike;
  cursor: String;
}

export interface CommentLikeEdgePromise extends Promise<CommentLikeEdge>, Fragmentable {
  node: <T = CommentLikePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentLikeEdgeSubscription
  extends Promise<AsyncIterator<CommentLikeEdge>>,
    Fragmentable {
  node: <T = CommentLikeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReviewEdge {
  node: Review;
  cursor: String;
}

export interface ReviewEdgePromise extends Promise<ReviewEdge>, Fragmentable {
  node: <T = ReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewEdgeSubscription extends Promise<AsyncIterator<ReviewEdge>>, Fragmentable {
  node: <T = ReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Tag {
  id: UUID;
  title: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<UUID>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  postTags: <T = FragmentableArray<PostTag>>(args?: {
    where?: PostTagWhereInput;
    orderBy?: PostTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TagSubscription extends Promise<AsyncIterator<Tag>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  postTags: <T = Promise<AsyncIterator<PostTagSubscription>>>(args?: {
    where?: PostTagWhereInput;
    orderBy?: PostTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
  id: () => Promise<UUID>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  postTags: <T = FragmentableArray<PostTag>>(args?: {
    where?: PostTagWhereInput;
    orderBy?: PostTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReviewPreviousValues {
  id: UUID;
  message: String;
  stars: Int;
  likes: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReviewPreviousValuesPromise extends Promise<ReviewPreviousValues>, Fragmentable {
  id: () => Promise<UUID>;
  message: () => Promise<String>;
  stars: () => Promise<Int>;
  likes: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  message: () => Promise<AsyncIterator<String>>;
  stars: () => Promise<AsyncIterator<Int>>;
  likes: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReviewSubscriptionPayload {
  mutation: MutationType;
  node: Review;
  updatedFields: String[];
  previousValues: ReviewPreviousValues;
}

export interface ReviewSubscriptionPayloadPromise
  extends Promise<ReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewPreviousValuesPromise>() => T;
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewPreviousValuesSubscription>() => T;
}

export interface Comment {
  id: UUID;
  message: String;
  likes: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<UUID>;
  message: () => Promise<String>;
  image: <T = ImagePromise>() => T;
  likes: () => Promise<Int>;
  post: <T = PostPromise>() => T;
  createdBy: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentSubscription extends Promise<AsyncIterator<Comment>>, Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  message: () => Promise<AsyncIterator<String>>;
  image: <T = ImageSubscription>() => T;
  likes: () => Promise<AsyncIterator<Int>>;
  post: <T = PostSubscription>() => T;
  createdBy: <T = AccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentNullablePromise extends Promise<Comment | null>, Fragmentable {
  id: () => Promise<UUID>;
  message: () => Promise<String>;
  image: <T = ImagePromise>() => T;
  likes: () => Promise<Int>;
  post: <T = PostPromise>() => T;
  createdBy: <T = AccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregatePostLike {
  count: Int;
}

export interface AggregatePostLikePromise extends Promise<AggregatePostLike>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostLikeSubscription
  extends Promise<AsyncIterator<AggregatePostLike>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise extends Promise<TagConnection>, Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise extends Promise<AggregateImage>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PetImageEdge {
  node: PetImage;
  cursor: String;
}

export interface PetImageEdgePromise extends Promise<PetImageEdge>, Fragmentable {
  node: <T = PetImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PetImageEdgeSubscription
  extends Promise<AsyncIterator<PetImageEdge>>,
    Fragmentable {
  node: <T = PetImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Json = any;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type UUID = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: 'Role',
    embedded: false,
  },
  {
    name: 'AccountStatus',
    embedded: false,
  },
  {
    name: 'Account',
    embedded: false,
  },
  {
    name: 'User',
    embedded: false,
  },
  {
    name: 'PostStatus',
    embedded: false,
  },
  {
    name: 'Post',
    embedded: false,
  },
  {
    name: 'PetType',
    embedded: false,
  },
  {
    name: 'Pet',
    embedded: false,
  },
  {
    name: 'Tag',
    embedded: false,
  },
  {
    name: 'PostTag',
    embedded: false,
  },
  {
    name: 'PetImage',
    embedded: false,
  },
  {
    name: 'Image',
    embedded: false,
  },
  {
    name: 'Comment',
    embedded: false,
  },
  {
    name: 'Review',
    embedded: false,
  },
  {
    name: 'Like',
    embedded: false,
  },
  {
    name: 'PostLike',
    embedded: false,
  },
  {
    name: 'CommentLike',
    embedded: false,
  },
  {
    name: 'ReviewLike',
    embedded: false,
  },
  {
    name: 'Report',
    embedded: false,
  },
];

/**
 * Type Defs
 */

export const prisma: Prisma;
